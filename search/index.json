[{"content":"React 渐进式学习路线 📌 学习原则 每个阶段 1-2 个核心项目（保持兴趣和成就感） 遇到问题再补充理论知识（避免过早陷入细节） 先模仿再创造（通过修改现有项目学习） 🚀 阶段路线图 阶段 1：HTML/CSS 生存技能（1-2周） 目标：能修改现有项目的样式和结构\n项目：重构 TodoList 的 UI\n学习重点：\n通过 Chrome 开发者工具调试样式 修改现有 CSS 类名和样式 使用 Flex/Grid 调整布局 添加简单的动画效果 资源：\nFlexbox 小游戏 CSS Diner（CSS 选择器练习） MDN 基础教程 阶段 2：JavaScript 核心操作（2-3周） 目标：能读懂并修改项目中的 JS 逻辑\n项目：给 TodoList 添加新功能\n学习重点：\n添加「编辑任务」功能 实现「本地存储」持久化 添加「任务分类」过滤功能 资源：\nJavaScript 30（每天 1 个小项目） 现代 JavaScript 教程（按需查阅） Codewars（编程挑战） 阶段 3：React 核心模式（3-4周） 目标：理解组件化开发思维\n项目：开发天气查询应用\n学习重点：\n组件拆分技巧（容器组件/展示组件） 掌握 useEffect 处理 API 请求 使用 Context 共享全局状态 资源：\nReact 官方文档（交互式教程） React 模式图解 EpicReact.dev（实战技巧） 阶段 4：现代工具链（2周） 目标：能配置和调试工程化项目\n项目：从零搭建项目脚手架\n学习重点：\n使用 Vite 初始化项目 配置 ESLint + Prettier 添加路由（React Router） 集成状态管理（Zustand/Jotai） 资源：\nVite 官方文档 React Router 教程 阶段 5：实战进阶（4-6周） 目标：体验真实项目开发流程\n项目：开发「个人博客系统」\n功能需求：\n文章列表/详情页 标签分类系统 评论功能 管理员后台 技术栈：\nNext.js（SSR） Markdown 解析 身份验证（NextAuth） 数据库（Supabase） 资源：\nNext.js 官方教程 Supabase 文档 阶段 6：大型项目实战（持续） 目标：培养代码阅读和协作能力\n学习方法：\n参与开源项目（从修改文档开始） 阅读 Ant Design 等优秀组件库源码 学习 Monorepo 项目管理（TurboRepo） 推荐项目：\nReact GitHub 源码 Vercel 开源项目 Shadcn UI（现代组件库） 💡 学习技巧 Debug 优先：遇到报错时先尝试自己解决（学会看错误信息） 暴力修改法：在副本项目里随意修改代码观察效果 3:1 原则：每写 3 小时代码，用 1 小时整理笔记 逆向工程：找到喜欢的网站/应用，尝试用 React 复现 🛠️ 工具推荐 代码沙盒：CodeSandbox（快速实验想法） AI 辅助：Cursor（代码智能补全） 知识管理：Obsidian（构建个人知识库） 📅 每日学习节奏（参考） 时间段 内容 09:00-10:30 项目编码（核心功能开发） 10:30-11:00 休息 + 整理问题清单 11:00-12:00 针对性学习（解决上午问题） 14:00-15:30 代码重构/功能优化 15:30-16:00 社区交流（Stack Overflow） 16:00-17:00 阅读源码/技术文章 通过「需求驱动学习」的方式，在解决实际问题的过程中自然掌握必要知识。记住：大型项目只是多个小功能的组合，保持迭代改进的心态更重要。\n","date":"2025-02-22T00:00:00Z","permalink":"https://godvvvzzz.github.io/p/react-study-plan/","title":"react学习计划"},{"content":"Hugo Stack Starter https://github.com/CaiJimmy/hugo-theme-stack-starter\n这是一个为 Hugo Stack 主题设计的快速上手模板，使用了 Hugo 模块 来加载主题。它提供了基础的主题结构和配置，同时配置了 GitHub Actions，可以自动将网站部署到 GitHub Pages。还包含一个每天自动更新主题的定时任务（cron job）。\n创建 GitHub 仓库 点击 GitHub 上的 Use this template 按钮。 将新仓库命名为 \u0026lt;用户名\u0026gt;.github.io。其中，用户名建议为全小写。 创建 GitHub Codespace 仓库创建完成后，创建一个与之关联的 GitHub Codespace。 Codespace 已经配置好了 Hugo 的最新扩展版本。 在终端中运行命令 hugo server，即可在浏览器中预览你的网站。 配置站点信息 检查仓库中的 config 文件夹，里面是站点的配置文件。 修改 config/_default/config.toml 文件中的 baseurl 属性，填入你的网站 URL。 部署到 GitHub Pages 打开仓库的 Settings -\u0026gt; Pages 页面。 将构建分支从 master 改为 gh-pages。 每次编辑完网站后，只需将更改提交并推送到仓库，GitHub Actions 会自动将网站部署到对应的 GitHub Pages。 如何写博客 本地下载hugo 以ububtu为例\n1. 下载 Hugo 最新版\n访问 Hugo 的 GitHub Releases 页面找到最新版下载链接： Hugo Releases\n或者直接通过命令行下载 hugo_extended 的 Linux 64 位版本：\n1 wget https://github.com/gohugoio/hugo/releases/download/v0.139.3/hugo_extended_0.139.3_Linux-64bit.tar.gz 2. 解压下载的文件\n解压 .tar.gz 文件：\n1 tar -xvzf hugo_extended_0.139.3_Linux-64bit.tar.gz 解压后会生成一个 hugo 二进制文件。\n3. 安装 Hugo\n将解压后的 hugo 二进制文件移动到系统路径（如 /usr/local/bin），以便全局使用：\n1 sudo mv hugo /usr/local/bin/ 4. 验证安装\n运行以下命令验证安装并检查版本：\n1 hugo version 输出示例：\n1 hugo v0.139.3+extended linux/amd64 BuildDate=2024-12-09T10:00:00Z 创建新文章 1 hugo new post/react-study-plan/index.md 在 content/post/react-study-plan/index.mdd 中编辑内容，例如：\n1 2 3 4 5 6 7 8 --- title: \u0026#34;My First Post\u0026#34; date: 2024-12-09 draft: false tags: [\u0026#34;hugo\u0026#34;, \u0026#34;theme\u0026#34;] categories: [\u0026#34;blog\u0026#34;] --- This is my first post with Hugo Stack theme! 启用评论 Stack 主题默认支持 Utterances评论系统，只需要在 /config/params.toml配置以下参数：\n1 2 3 4 5 6 7 8 9 10 ## Comments [comments] enabled = true provider = \u0026#34;utterances\u0026#34; [comments.utterances] repo = \u0026#34;GODVvVZzz/blog-comments\u0026#34; issueTerm = \u0026#34;pathname\u0026#34; # 评论与文章的关联方式，可选 title, pathname, url label = \u0026#34;Comments\u0026#34; # GitHub Issue 的标签名称 theme = \u0026#34;github-light\u0026#34; # 评论框的主题风格 本地预览 在项目根目录下执行hugo server，访问http://localhost:1313/\n标签\u0026amp;tag配置 直接在文章 Front Matter中添加即可\n1 2 3 4 5 6 7 8 9 --- title: \u0026#34;测试文章\u0026#34; date: 2024-12-18 categories: - 测试分类 tags: - 标签1 - 标签2 --- 其他 配置项目git忽略文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # Hugo 缓存目录 .cache/ hugo_stats.json resources/ # 构建输出目录 public/ # Node.js 和前端工具生成的文件（如适用） node_modules/ dist/ # 临时文件和日志 *.log *.lock .DS_Store Thumbs.db *.tmp *.bak # TypeScript 或编辑器相关配置文件 tsconfig.json jsconfig.json # 操作系统或编辑器生成的文件 .idea/ .vscode/ *.swp *~ # Hugo 模块缓存 go.sum go.mod ","date":"2024-12-11T09:44:53+08:00","permalink":"https://godvvvzzz.github.io/p/hugo-stack-study/","title":"记录本博客搭建过程"},{"content":"文件描述符（FD）概述 文件描述符（FD）是操作系统内核用来标识已打开文件的非负整数索引。在程序中，文件描述符用于文件的读写操作，如通过read、write系统调用。在POSIX标准中，文件描述符0、1、2分别代表标准输入、标准输出和标准错误。\nFD泄露现象 当一个进程打开的文件描述符数量超过系统限制（默认为1024），系统将无法为新文件分配描述符，并可能抛出“Too many open files”错误。这通常意味着有未正确关闭的文件或连接，导致描述符占用过高。\n排查步骤 发现问题 ：通过监控系统发现服务的文件描述符数量异常增长。 查找服务PID ：使用ps aux | grep [服务名]命令找出目标服务的进程ID。 查看当前服务占用FD数量 ：执行ls /proc/[PID]/fd | wc -l检查服务当前打开的文件描述符数量。 查看FD使用情况 ：详细列出当前服务的文件描述符使用情况，ls -ls /proc/[PID]/fd。 检查网络连接 ：使用ss -anp |grep [PID]命令查看服务相关的网络连接，帮助定位可能的泄露来源。 典型案例 以某服务的FD泄露为例：\n现象 ：文件描述符持续增长，达到1w+。 原因 ：服务在高QPS（200~300）下调用第三方验证接口，由于HTTP连接默认超时时间较长（60s），且未主动关闭连接，导致大量描述符持续占用。 复现 ：通过脚本模拟高频率请求，持续观察FD数量变化，验证泄露情况。 排查 ：利用上述步骤定位到问题来源为HTTP请求未正确关闭。 代码修改 ：增加了连接超时和读写超时设置，确保连接在指定时间内被关闭，从而释放描述符。 结果 ：服务使用的FD数量显著下降，泄露问题得到解决。 ","date":"2024-12-10T00:00:00Z","permalink":"https://godvvvzzz.github.io/p/fd-leak-investigation/","title":"FD泄露排查"},{"content":" 一次 Go 服务内存占用高但 pprof 却显示正常的排查经历 最近在生产环境中遇到一个挺“诡异”的问题：Go 服务的物理内存占用非常高，但用 pprof 查看内存分布却发现 Go 自己统计的内存占用并不大。这篇文章记录一下整个排查和优化过程，以及我对 Go 内存管理和系统行为的一些理解。\n一、问题背景 我们有一个定时任务服务，定期会上传文件(先读取到内存中，再上传)。监控告警频繁提示该进程内存占用超过阈值，比如：\n1 Resident Memory (RSS) = 3.5GB 而这个服务按理说业务逻辑很轻，正常运行时不该超过 1GB。\n于是我登录机器一看，top 输出确实很“吓人”：\n1 2 PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 22103 root 20 0 4694.7m 3582.4m 856 S 0.5 45.7 5:12.23 myservice 但当我通过 pprof 分析堆内存时，发现完全对不上：\n1 2 3 4 5 6 7 (pprof) top Showing nodes accounting for 45.55MB, 93.47% of 48.72MB total Showing top 10 nodes out of 48 flat flat% sum% cum cum% 20.12MB 41.32% 41.32% 20.12MB 41.32% runtime.allocmcache 15.22MB 31.23% 72.55% 15.22MB 31.23% mypackage.(*Buffer).Append ... 堆占用才几十 MB，加上其他组件，最多也就一两百 MB，跟 top 显示的 3GB 根本不匹配。\n二、初步分析 这种现象在 Go 服务中其实并不罕见： Go 的内存分配器（runtime.mallocgc）和系统内存管理之间存在一层缓存。\n也就是说：\npprof 看到的“堆内存”是 Go 自己认为“正在使用”的内存 而 top 看到的 RSS（Resident Set Size）是操作系统层面上，这个进程实际保留的物理内存 Go 为了提升性能，会从系统申请一大块内存，然后自己在用户态分配使用。当某部分内存暂时不用时，Go runtime 不一定马上还给操作系统，而是保留在“空闲池”里，以便下次复用。这块内存，系统不会立即回收，而是在有内存压力时才回收。\n这就导致了：\nGo 服务的内存使用量下降，但系统的 RSS 并不会同步减少。\n三、验证猜想 为了进一步验证，我用了以下几种方法。\n1. 查看 runtime.MemStats 1 2 3 4 5 6 var m runtime.MemStats runtime.ReadMemStats(\u0026amp;m) fmt.Printf(\u0026#34;Alloc = %v MiB\u0026#34;, m.Alloc/1024/1024) fmt.Printf(\u0026#34;TotalAlloc = %v MiB\u0026#34;, m.TotalAlloc/1024/1024) fmt.Printf(\u0026#34;Sys = %v MiB\u0026#34;, m.Sys/1024/1024) fmt.Printf(\u0026#34;HeapReleased = %v MiB\u0026#34;, m.HeapReleased/1024/1024) 输出类似：\n1 2 3 4 Alloc = 85 MiB TotalAlloc = 325 MiB Sys = 2048 MiB HeapReleased = 128 MiB 其中几个关键字段含义如下：\n字段 含义 Alloc 应用正在使用的堆内存 Sys Go 向操作系统申请的总内存（包括堆、栈、缓存等） HeapReleased Go 已经释放给操作系统的堆内存 HeapIdle - HeapReleased Go 持有但暂未释放的内存 从这些数据可以看出：\nGo 程序只用了 85MB 堆； 但向系统申请了 2GB； 其中仅 128MB 被释放回系统。 =\u0026gt; 说明大部分空闲内存仍然在 Go runtime 手上，没有还给内核。\n2. 通过 pprof 查看（无需改代码） 实际上，pprof 的 /debug/pprof/heap?debug=1 输出中，已经包含与 runtime.MemStats 同源的内存统计信息。\n可以直接执行：\n1 curl http://\u0026lt;host\u0026gt;:6060/debug/pprof/heap?debug=1 输出示例：\n1 2 3 4 5 6 7 heap profile: 12: 8 [24576 bytes]: total 12.3 MB # runtime.MemStats # Alloc = 85 MiB # TotalAlloc = 325 MiB # Sys = 2048 MiB # HeapReleased = 128 MiB ... 这些字段和前面 runtime.ReadMemStats() 打印的内容一致，代表：\n当前堆使用量（Alloc） 历史累计分配量（TotalAlloc） 向系统申请总量（Sys） 已释放回系统的部分（HeapReleased） 也可以直接通过 pprof 的 heap?debug=1 接口来判断：\nGo 当前的实际堆使用； 系统层面申请与归还的差距； 内存是否被 runtime 保留未释放。 另外，还可以下载完整堆文件：\n1 2 curl -o heap.out http://\u0026lt;host\u0026gt;:6060/debug/pprof/heap go tool pprof -http=:8081 heap.out 这样能在本地以图形方式直观查看内存分配和对象占用情况。\n四、深入理解 Go 内存回收策略 Go 的内存回收机制其实有两层：\nGo 层 GC： 回收程序中不再使用的对象，释放到 Go 的空闲堆中； 系统层释放： Go 决定是否把空闲堆空间还给操作系统。 Go 默认通过 MADV_FREE（Linux 内核特性）标记这些内存区域为“可重用”，但并不真正清除或释放它们。 操作系统在内存紧张时会自动回收这些区域，但在内存宽裕时，它们依然算作 RSS。\n这意味着：从 top 角度看，这块内存仍然被占着；但从 pprof 看，它已经“空闲”。\n五、解决思路：使用 GODEBUG 调整回收策略 Go 从 1.12 版本开始支持环境变量 GODEBUG=madvdontneed=1 来改变这种行为。\n默认行为：\n1 GODEBUG=madvdontneed=0 （即使用 MADV_FREE） 优化后行为：\n1 GODEBUG=madvdontneed=1 （改用 MADV_DONTNEED） 区别在于：\nMADV_FREE: 内存被标记为“可重用”，但不会立即归还系统； MADV_DONTNEED: 立即告诉内核这部分内存可以被回收，RSS 会立刻下降。 于是我尝试在服务启动脚本中添加这一行：\n1 export GODEBUG=madvdontneed=1 然后重启服务。\n六、结果验证 观察现象：\n服务启动后内存峰值仍然会上升； 但当负载下降、GC 运行后，RSS 明显下降； top 显示的内存占用与 pprof 统计的堆大小更为接近； 内存告警消失。 示例数据（对比优化前后）：\n阶段 pprof 堆占用 top RSS 占用 说明 优化前 100MB 3.2GB Go 未归还空闲内存 优化后 100MB 500MB Go 主动释放空闲内存 效果立竿见影。\n七、知识点总结 这次问题涉及几个核心知识点，整理如下：\nGo runtime 内存模型 Alloc 是程序真实使用的； Sys 是从系统申请的； Go 不一定会马上释放空闲内存回系统。 Linux 内存管理机制 RSS（Resident Set Size）反映进程实际驻留物理内存； MADV_FREE：延迟释放； MADV_DONTNEED：立即释放。 pprof 与 top 的差异 pprof 统计的是 Go 内部内存； top 统计的是操作系统层面的物理内存； 两者的差异往往由 runtime 与内核的回收策略造成。 调优手段 设置 GODEBUG=madvdontneed=1； 或者通过 debug.FreeOSMemory() 手动触发系统级释放； 也可通过 GOGC 参数控制 GC 频率平衡性能与内存占用。 八、结语 这次排查让我更深刻地理解了 Go 的内存行为：Go 的 GC 负责逻辑回收，而内核才负责物理释放。 默认情况下 Go 倾向于性能优先，会缓存一部分空闲内存。但在某些场景（比如定时任务服务，每次运行时间间隔较久）下，我们更希望 Go 积极释放空闲内存，这时候 GODEBUG=madvdontneed=1 就是一个非常实用的优化手段。\n如果用一句话总结：\npprof 看到的只是“Go 眼中的世界”，而 top 看到的才是“操作系统眼中的世界”。两者的差异，往往藏着性能优化的关键。\n参考文档 Go 内存释放策略：MADV_DONTNEED 和 MADV_FREE\nGolang内存问题排查 踩坑记：go服务内存暴涨\n","date":"2025-11-04T00:00:28+08:00","permalink":"https://godvvvzzz.github.io/p/%E8%AE%B0%E4%B8%80%E6%AC%A1go%E6%9C%8D%E5%8A%A1%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E9%AB%98%E6%8A%A5%E8%AD%A6%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95/","title":"记一次go服务内存占用高报警排查记录"},{"content":"🗺️ 后端工程师成长路径概览 RoadMap:https://cloud.tencent.com.cn/developer/article/2354207\n核心理念：后端工程师的成长是从“实现功能”的编码者，进化为“构建可靠、高效、可扩展系统”的工程师，最终成为能够驾驭技术不确定性、驱动业务发展的决策者。\n深挖底层与业务，系统好奇是根基（好奇） 学抽象建体系，动手实践出真知（学习） 专精设计懂权衡，架构能力是壁垒（架构） 工程协作提效能，影响团队共进步（影响） 严谨韧性保稳定，构建线上确定性（严谨） 名师引路破瓶颈，加速成长为栋梁（加速） 成长维度 初级阶段 (编码者) 进阶阶段 (工程师) 高级阶段 (决策者) 核心关注点 实现功能、完成需求 系统设计、性能优化、稳定性保障 技术战略、业务驱动、团队赋能 技术深度 学习框架、API调用 深挖底层原理（操作系统、网络、数据库） 构建技术体系，形成技术判断力 影响力范围 个人任务、模块代码 团队项目、工程规范、架构设计 跨团队协作、技术规划、人才培养 💡 结论 深度系统好奇心：从“怎么做”到“为什么这么做”\n不满足于表面功能实现，要主动探究底层原理（如操作系统、网络协议、数据库）和业务逻辑的深层原因。这能让你在出现复杂问题时快速定位根因，做出更明智的技术决策。\n高效学习与抽象力\n方法：优先阅读官方文档和源码以获得最准确信息。 关键：勤于动手实践，并通过抽象与归纳，从纷繁的技术和业务中提炼出共通的设计模式和领域模型，构建自己的知识体系。 善用工具：合理利用AI工具辅助代码生成、技术调研和问题排查，但核心是培养自身的技术判断力。 架构与设计能力：从功能实现到系统雕塑\n打造技术专长：在广博的基础上，选择一个如性能优化、分布式系统或安全稳定性等高价值领域进行深度钻研，建立个人技术品牌。 掌握权衡艺术：深刻理解并在性能与成本、一致性与可用性等关键维度之间做出明智的权衡。 输出蓝图：能够产出清晰的技术方案文档和架构图，并清晰地阐述其背后的思考。 工程与协作影响力：从个人贡献者到团队杠杆\n你的价值不再仅仅是你写了多少代码，而在于你如何提升整个团队的效能。这包括：\n对代码：具备“代码洁癖”，积极推动工程规范。 对团队：在评审中提供深度反馈，主动分享知识，赋能他人。 对业务：主动沟通，理解业务背景，用技术手段直接创造业务价值。 严谨与韧性：在不确定性中构建确定性\n这是后端工程师的基石素养。要对线上环境抱有敬畏之心，通过完善的日志、监控和系统性思维来保障稳定性。面对故障和难题，要具备冷静排查和彻底复盘的能力，并拥有“死磕”的韧性。\n关键加速器：寻找“架构师导师”\n一位经验丰富的导师能在你面临技术抉择时点拨迷津，分享宝贵的踩坑经验，并通过高标准的代码评审提供成长反馈。你可以从团队内部或外部技术社区中寻找这样的引路人。\n💎 细节 一、深度系统好奇心：从“怎么做”到“为什么这么做” 对象与行动：\n底层原理：不满足于API调用，深挖操作系统（进程/线程/IO）、网络（TCP/IP/HTTP）、数据库（索引/事务/锁）、中间件（消息队列/缓存）的工作原理。 业务逻辑：深入理解你所支持的业务领域（如电商、社交、金融），明白每一行代码背后的商业意图和用户价值。 依赖生态：了解你使用的框架、组件、云服务的核心机制、优劣和边界。知其然，并知其所以然。 全局架构：跳出自己的一亩三分地，去理解整个系统的架构设计、模块划分、数据流、部署流程以及它们为何如此设计。 目的：在出现疑难杂症时，能快速定位根因；在设计方案时，能做出更符合底层原理和长期发展的明智选择。\n二、高效学习与抽象力：在技术浪潮中屹立不倒 核心方法：\n官方文档优先（深度访谈）：像产品经理访谈用户一样，精读官方文档和源码，这是最一手、最准确的信息。博客和二手教程（电话访谈）可作为辅助，但不能替代。 动手实践（构建原型）：学习新技术时，亲手搭建、写Demo、做压测，在实践中感受其特性和瓶颈。 抽象与归纳：从纷繁复杂的技术和业务逻辑中，抽象出共通的设计模式、架构模式和领域模型。例如，能否将不同的业务需求抽象为统一的任务调度模型？ AI高效辅助： 代码生成与解释：让AI生成样板代码、单元测试、或解释一段复杂的遗留代码。 技术调研：快速获取不同技术方案的对比、最佳实践和潜在风险。 问题排查：提供错误日志，让AI辅助分析可能的原因。 核心：构建自己的知识体系和技术判断力，能快速甄别技术的价值，并将其抽象为可复用的解决方案，而非被动地追逐最新名词。\n三、架构与设计能力：从功能实现到系统雕塑 行动策略：\n打造技术“利基”：在广度之上，选择一个或多个高价值领域深度钻研，建立技术品牌，例如： 性能优化专家：深入JVM/GC、数据库调优、缓存体系、高并发服务。 分布式系统专家：精通微服务治理、分布式事务、一致性协议、弹性设计。 数据领域专家：深耕大数据平台、实时计算、数据仓库与湖仓一体。 安全与稳定性专家：专精于架构安全、流量防护、故障演练、SLA保障。 设计原则与权衡：掌握SOLID、DRY、KISS等设计原则，并能在实际设计中灵活运用。深刻理解并在性能VS成本、一致性VS可用性、开发效率VS系统稳定性、技术前瞻性VS团队技术栈之间做出明智的权衡。 输出蓝图：能够产出清晰的技术方案文档、架构图，并能清晰地阐述技术选型理由、潜在风险和演进路线。 目标：从“实现一个接口”的视角，上升到“设计一个优雅、健壮、易于演进的服务”的层面，成为团队的技术设计核心。\n四、工程与协作影响力：从个人贡献者到团队杠杆 如何升级：\n对代码与工程： 代码洁癖：写出清晰、可读、可维护的代码，视为职业素养。积极重构，偿还技术债。 工程规范推动者：主动推动团队的代码规范、CI/CD流程、单元测试覆盖率、文档文化。 对同事与团队： 高效协作：在设计评审、代码评审中提供建设性、有深度的反馈，帮助团队共同成长。 知识传承：主动分享技术难点、设计思路和复盘总结，将个人能力转化为团队资产。 赋能他人：设计易于理解和使用的接口、SDK、平台工具，降低他人的使用成本。 对业务与产品： 主动沟通：主动与产品/前端沟通，了解业务背景，识别技术风险，提出更优的技术实现方案，而不仅仅是被动接收需求。 用技术创造价值：通过技术手段（如引入缓存、优化查询）直接带来业务指标（如响应时间、吞吐量）的提升，并清晰地展示其价值。 核心：价值不再仅仅是写了多少行代码，而是如何通过技术能力、工程素养和协作精神，提升整个团队的产出效率和质量。\n五、严谨与韧性：在复杂性与不确定性中构建确定性 必备特质：\n严谨性： 敬畏线上：对每一次变更都抱有敬畏之心，严格遵守上线流程，做好回滚预案。 日志与监控：坚信“可观测性是最好的医生”，为自己开发的服务设计完善的日志、监控和告警。 系统性思维： 考虑问题时，能想到上下游依赖、流量洪峰、单点故障、安全漏洞等方方面面。 养成“如果\u0026hellip;会\u0026hellip;”的思维习惯，提前预判风险。 问题驱动与韧性： 面对线上故障，能冷静、清晰、按优先级地进行排查、定位和修复，并事后进行彻底复盘。 面对技术难题，有“死磕”的精神，乐于钻进复杂的代码库和日志中寻找线索。 耐心与远见：懂得“慢就是快”，在前期投入足够的设计和测试时间，避免后期无尽的修补。对技术体系的建设有长期主义的耐心。 六、关键加速器：寻找你的“架构师导师”（Architect Mentor） 为什么至关重要：后端技术的深度和架构设计的艺术，需要高人指点。一位好的导师能帮你：\n点拨迷津：在你面对多个技术方案犹豫不决时，一针见血地指出优劣和背后的权衡。 传授“内功”：分享他踩过的坑、解决问题的思维模式、架构演进的历程，这些是无价之宝。 代码与设计评审：以极高的标准评审你的代码和设计，让你看到差距和提升方向。 提供舞台：给予你负责更具挑战性模块的机会，在实战中锻炼你。 职业导航：帮你规划在技术（专家路线/管理路线）上的成长路径。 如何寻找：\n内部：你的技术主管、架构师团队中的资深成员、你敬佩的其他技术团队负责人。 外部：技术社区/大会上的演讲者、开源项目负责人、技术博客的作者。 关键：带着你思考过的技术方案、遇到的具体难题、或者阅读源码后的困惑去请教，让对方看到你的潜力和诚意。 ","date":"2025-10-27T23:01:41+08:00","permalink":"https://godvvvzzz.github.io/p/backend-dev-plan/","title":"Backend Dev Plan"},{"content":" 核心原则 访问场景 推荐域名类型 说明 前端 → 后端接口 内网域名/IP 前端与后端部署在同一内网，通过反向代理通信，减少公网暴露风险。 客户端 → 后端接口 外网域名 客户端（如移动端、第三方）需通过公网访问，需暴露外网域名并加固安全。 典型场景及配置方案 场景1：纯Web应用（仅前端调用后端） 架构特点：\n前端部署在公网（如Nginx/CDN），后端在内网。 所有接口仅由前端调用，客户端不直接访问后端。 配置方案：\n前端调用后端：Nginx使用内网域名/IP代理后端服务（如 proxy_pass http://internal-api.example.com）。 客户端访问：仅访问前端域名（如 https://www.example.com），不暴露后端接口。 1 2 3 4 5 # 前端Nginx配置 location /api/ { proxy_pass http://internal-api.example.com:8080; # 内网域名 proxy_set_header Host $host; } 场景2：混合应用（前端+客户端均需调用后端） 架构特点：\n后端需同时服务前端（Web）和客户端（App/第三方）。 需区分内部接口和开放接口。 配置方案：\n前端调用后端：通过内网域名/IP（走反向代理）。 客户端调用后端：通过外网域名（如 https://api.example.com），配合API网关、鉴权和限流。 1 2 3 4 5 6 7 8 9 10 # 对外API网关配置 server { listen 443 ssl; server_name api.example.com; # 外网域名 location /public-api/ { proxy_pass http://backend-cluster; # 后端集群内网地址 # 安全加固：API密钥验证、速率限制等 } } 场景3：全开放API服务（如第三方集成） 架构特点： 后端需完全暴露给公网，供多客户端直接调用。 配置方案： 统一使用外网域名（如 https://api.example.com）。 通过API网关管理流量，并启用HTTPS、OAuth2、IP白名单等安全措施。 安全最佳实践 内网通信加固\n使用内网域名/IP，避免后端直接暴露在公网。\n通过防火墙限制后端端口仅允许前端服务器IP访问。\n1 2 3 # 后端服务器防火墙规则（示例） sudo ufw allow from 前端服务器IP to any port 8080 sudo ufw deny 8080 # 禁止其他IP访问 外网接口防护\nHTTPS加密：强制所有外网域名使用SSL/TLS。\n鉴权机制：JWT、OAuth2、API Key等。\n速率限制：防止DDoS和滥用。\n1 2 3 4 5 6 7 # Nginx限流配置 limit_req_zone $binary_remote_addr zone=api_rate:10m rate=10r/s; location /api/ { limit_req zone=api_rate burst=20; proxy_pass http://backend; } 监控与日志\n记录所有外网接口的访问日志。 使用工具（如Prometheus+Grafana）监控API健康状态。 常见误区与解答 误区1：所有接口都需通过外网暴露。 ​解答：仅客户端直接调用的接口需外网域名，前端调用的接口应通过内网通信。 误区2：内网域名不需要HTTPS。 ​解答：内网通信也应启用HTTPS（如自签证书），防止内部流量被窃听。 误区3：外网接口仅靠防火墙保护足够。 ​解答：需多层防御（HTTPS+鉴权+WAF），防火墙仅是第一道屏障。 总结 前端调用后端 → 优先使用内网域名/IP，通过反向代理隐藏后端。 客户端调用后端 → 使用外网域名，严格加固安全策略。 始终遵循最小暴露原则，减少攻击面，结合业务需求设计网络架构。 场景1 详解 在前后端分离的架构中，通过 Nginx 反向代理实现浏览器间接访问内网后端服务的链路如下：\n完整交互流程（以访问 https://example.com 为例）\n1 2 3 4 5 6 7 8 9 10 11 sequenceDiagram participant 浏览器 participant 前端服务器(Nginx) participant 后端服务器 浏览器-\u0026gt;\u0026gt;前端服务器(Nginx): 1. 请求前端页面（GET /） 前端服务器(Nginx)-\u0026gt;\u0026gt;浏览器: 2. 返回HTML/CSS/JS文件 浏览器-\u0026gt;\u0026gt;前端服务器(Nginx): 3. 发起API请求（GET /api/todos） 前端服务器(Nginx)-\u0026gt;\u0026gt;后端服务器: 4. 转发请求到内网地址（如http://10.0.0.2:8080） 后端服务器-\u0026gt;\u0026gt;前端服务器(Nginx): 5. 返回API响应数据 前端服务器(Nginx)-\u0026gt;\u0026gt;浏览器: 6. 返回数据给浏览器 关键步骤详解 浏览器请求前端页面 用户输入：访问 https://example.com。 DNS解析：浏览器通过DNS查询得到 example.com 的公网IP（如 122.51.70.205）。 请求前端资源：浏览器向该IP的80/443端口发送请求，获取 index.html 和静态资源（JS/CSS）。 前端服务器（Nginx）响应静态文件 Nginx配置：托管前端打包后的文件。\n1 2 3 4 5 6 7 8 9 10 server { listen 80; server_name example.com; root /var/www/dist; # 前端文件目录 index index.html; location / { try_files $uri $uri/ /index.html; # 处理前端路由 } } 浏览器执行JS代码发起API请求 前端代码逻辑：JS中调用 fetch(\u0026quot;/api/todos\u0026quot;)。 实际请求地址：浏览器会将其解析为 https://example.com/api/todos（同源请求）。 Nginx代理转发到后端服务器 Nginx反向代理规则：匹配/api/路径，转发到内网后端。\n1 2 3 4 5 location /api/ { proxy_pass http://10.0.0.2:8080; # 后端内网IP和端口 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } 内网通信：Nginx将请求发送到后端服务器的内网地址 10.0.0.2:8080。\n后端服务器处理请求 监听端口：后端服务运行在内网服务器的 8080 端口。 安全限制：防火墙仅允许来自前端服务器IP的请求（如 10.0.0.1）。 数据返回浏览器 响应路径：后端 → Nginx → 浏览器。 浏览器视角：全程只与 example.com 通信，感知不到后端服务器的存在。 为什么后端无需暴露公网？ Nginx的中转作用\n所有请求通过Nginx进入，后端服务只需在内网监听端口，无需公网IP或端口映射。 防火墙保护\n后端服务器的防火墙可配置为仅接受来自前端服务器内网IP的请求：\n1 2 3 # 后端服务器防火墙规则（示例） sudo ufw allow from 10.0.0.1 to any port 8080 # 仅允许前端服务器访问 sudo ufw deny 8080 # 禁止其他IP访问 安全性提升\n后端不暴露公网，减少被扫描攻击的风险。 常见问题解答 Q1：为什么浏览器不直接请求后端地址？ 同源策略：前端代码部署在 example.com，若直接请求 http://10.0.0.2:8080/api 会触发跨域错误（CORS）。 解决方案：通过Nginx代理统一域名，规避跨域问题。 Q2：如何保证内网通信安全？ 使用VPN或专线：前后端服务器通过私有网络通信。 内网HTTPS：即使在内网，也建议为后端服务启用HTTPS。 Q3：如何扩展多台后端服务器？ 负载均衡：在Nginx中配置upstream模块：\n1 2 3 4 5 6 7 upstream backend { server 10.0.0.2:8080 weight=1; server 10.0.0.3:8080 weight=2; } location /api/ { proxy_pass http://backend; } 总结 核心逻辑：Nginx作为中间层，将公网请求转发到内网后端，隐藏后端细节。 安全要点：后端仅在内网监听，通过防火墙限制访问来源。 优势：前端域名统一管理请求，提升安全性和扩展性。 dns nginx如何协作的 1. DNS 解析阶段：域名到 Nginx 服务器的 IP 用户访问域名：例如 https://www.example.com。 DNS 查询： 浏览器向本地 DNS 缓存或运营商 DNS 服务器查询 www.example.com 的 IP。 DNS 服务器返回该域名对应的 Nginx 服务器的公网 IP（如 122.51.70.205）。 结果：浏览器的所有请求（无论路径是 /、/api/xxx 或其他）都会发送到 122.51.70.205 的 80/443 端口。 2. Nginx 接收请求后的处理逻辑 Nginx 不依赖域名后缀（如 /api），而是通过以下两个关键机制确定如何转发请求：\n5(1) 根据 Host 头匹配 server 块\nHTTP 请求头：浏览器在请求中自动携带 Host: www.example.com。\nNginx 配置：通过server_name匹配域名，决定由哪个server块处理请求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 示例：处理 www.example.com 的请求 server { listen 80; server_name www.example.com; # 关键！匹配 Host 头 location / { root /var/www/html; # 返回前端页面 } location /api/ { proxy_pass http://backend; # 转发到后端 } } # 另一个域名（如 api.example.com）的配置 server { listen 80; server_name api.example.com; # 匹配不同 Host 头 location / { proxy_pass http://another-backend; # 转发到其他后端 } } 核心逻辑： Nginx 通过 server_name 区分不同域名的请求，即使它们指向同一个 IP。\n(2) 根据 location 块匹配路径\n路径匹配：在同一个server块内，通过location规则（如/api/）进一步决定是否转发到后端。\n1 2 3 location /api/ { proxy_pass http://10.0.0.2:8080; # 转发到内网后端 } 最终流程： 域名解析 → Nginx 接收请求 → 匹配 server_name → 匹配 location → 转发或返回静态文件。\n3. 为什么域名后缀（如 /api）不是关键？ 误区澄清： Nginx ​不依赖 URL 中的域名后缀​（如 https://www.example.com/api/xxx 中的 api 路径）来决定转发，而是通过以下两步： 域名级别：根据 Host 头选择 server 块（如 www.example.com vs api.example.com）。 路径级别：在选中的 server 块内，根据 location 匹配路径（如 /api/）。 示例场景： 如果用户访问https://www.example.com/api/todos： Nginx 先匹配 server_name www.example.com 的 server 块。 再通过 location /api/ 将请求转发到后端。 如果用户访问https://api.example.com/todos： Nginx 匹配 server_name api.example.com 的 server 块。 根据该 server 块的 location / 直接转发到另一个后端。 关键总结 DNS 解析只是入口： 仅负责将域名解析到 Nginx 服务器的 IP，不涉及后续路径处理。 Nginx 的核心匹配逻辑： 第 1 层：通过 server_name 匹配域名（Host 头）。 第 2 层：通过 location 匹配路径。 隐藏后端的关键： 浏览器始终只与 Nginx 通信，后端服务的 IP、端口、内网架构对浏览器完全透明。 配置示例：多域名 + 路径转发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 域名 www.example.com：处理前端页面和API server { listen 80; server_name www.example.com; # 前端静态资源 location / { root /var/www/html; index index.html; } # 转发API请求到后端 location /api/ { proxy_pass http://10.0.0.2:8080; } } # 域名 api.example.com：直接转发到另一个后端 server { listen 80; server_name api.example.com; location / { proxy_pass http://10.0.0.3:8080; } } 测试方法 验证 DNS 解析：\n1 dig www.example.com # 查看是否返回 Nginx 服务器 IP 验证 Nginx 域名匹配：\n1 2 3 # 模拟携带不同 Host 头的请求 curl -H \u0026#34;Host: www.example.com\u0026#34; http://122.51.70.205/api/todos curl -H \u0026#34;Host: api.example.com\u0026#34; http://122.51.70.205/todos 浏览器调试：\n在浏览器开发者工具的 Network 选项卡中，观察请求的 Host 头和响应来源。 常见问题 Q1：如果多个域名指向同一个 IP，Nginx 如何区分？\n答案：通过 server_name 匹配请求头中的 Host 字段，无需不同 IP。 Q2：Nginx 能根据 URL 路径（如 /api）直接转发吗？\n答案：可以，但需在同一 server 块内配置 location 规则，而不是依赖域名后缀。 Q3：如何实现类似 https://example.com/api 和 https://api.example.com 的共存？\n方案： https://example.com/api → 使用 server_name example.com + location /api。 https://api.example.com → 使用 server_name api.example.com + location /。 通过以上机制，Nginx 完美实现了 域名解析 → 请求分发 → 后端隐藏 的全链路控制。\n","date":"2025-02-27T00:49:52+08:00","permalink":"https://godvvvzzz.github.io/p/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%9F%E5%90%8D%E4%BD%BF%E7%94%A8%E6%8E%A2%E8%AE%A8/","title":"前后端域名使用探讨"},{"content":"Linux 文件权限基础 权限三元组 Linux 中每个文件/目录的权限由 3 组字符表示（共 9 位）：\n1 2 3 4 rwx rwx rwx │││ │││ │││ └┬┘ └┬┘ └┬┘ Owner Group Others r = 读 (4)\nw = 写 (2)\nx = 执行/进入目录 (1)\n数字表示法 755 = rwxr-xr-x\n644 = rw-r--r--\n777 = rwxrwxrwx（危险！）\nNginx 权限需求分析 Nginx 运行身份 默认以 www-data 用户和组运行（可通过 ps aux | grep nginx 确认）。 需要至少以下权限： 目录：r-x（读 + 执行）\n文件：r--（读）\n关键路径 假设你的项目路径为： 1 /home/ubuntu/work/react-todo-demo/dist/ 分步权限配置指南 步骤 1：检查当前权限 查看完整路径权限链（关键！） 1 namei -l /home/ubuntu/work/react-todo-demo/dist/index.html 示例输出：\n1 2 3 4 5 6 7 8 f: /home/ubuntu/work/react-todo-demo/dist/index.html drwxr-xr-x root root / drwxr-xr-x root root home drwxr-x--- ubuntu ubuntu ubuntu # 问题所在！ drwxrwxr-x ubuntu ubuntu work drwxrwxr-x ubuntu ubuntu react-todo-demo drwxrwxrwx www-data www-data dist -rwxrwxrwx www-data www-data index.html 步骤 2：设置父目录权限 开放父目录的 x 权限（允许进入目录） 1 2 3 sudo chmod o+x /home/ubuntu sudo chmod o+x /home/ubuntu/work sudo chmod o+x /home/ubuntu/work/react-todo-demo 验证 1 namei -l /home/ubuntu/work/react-todo-demo/dist/index.html | grep ubuntu 应看到类似：\n1 drwx--x--x 步骤 3：设置项目目录权限 进入项目目录 1 cd /home/ubuntu/work/react-todo-demo 设置目录权限（755 = owner 可写，其他人只读+执行） 1 sudo find dist/ -type d -exec chmod 755 {} \\; 设置文件权限（644 = owner 可写，其他人只读） 1 sudo find dist/ -type f -exec chmod 644 {} \\; 验证 1 ls -l dist/ 应显示：\n1 2 drwxr-xr-x 目录 -rw-r--r-- 文件 步骤 4：设置所有权（推荐方案） 将目录组改为 www-data 1 sudo chown -R ubuntu:www-data /home/ubuntu/work/react-todo-demo/dist 设置组写权限（可选，如果你需要自动构建） 1 sudo chmod -R g+w dist/ 最终权限结构：\ndrwxrwxr-x 目录（owner:ubuntu, group:www-data）\n-rw-rw-r-- 文件（owner:ubuntu, group:www-data）\n安全增强配置 方案 A：严格模式（推荐） 父目录权限（仅允许 ubuntu 用户和组访问） 1 2 3 sudo chmod 750 /home/ubuntu sudo chmod 750 /home/ubuntu/work sudo chmod 750 /home/ubuntu/work/react-todo-demo 将 www-data 用户加入 ubuntu 组 1 sudo usermod -aG ubuntu www-data 项目目录权限 1 2 sudo chmod -R 750 /home/ubuntu/work/react-todo-demo/dist sudo chown -R ubuntu:ubuntu /home/ubuntu/work/react-todo-demo/dist 方案 B：宽松模式（快速修复） 宽松权限配置 1 2 sudo chmod -R 755 /home/ubuntu/work/react-todo-demo sudo chown -R ubuntu:www-data /home/ubuntu/work/react-todo-demo SELinux/AppArmor 处理 如果系统启用了强制访问控制：\n临时禁用（测试用） 1 2 sudo setenforce 0 # SELinux sudo systemctl stop apparmor # AppArmor 永久解决方案 1 2 sudo semanage fcontext -a -t httpd_sys_content_t \u0026#34;/home/ubuntu/work/react-todo-demo/dist(/.*)?\u0026#34; sudo restorecon -Rv /home/ubuntu/work/react-todo-demo/dist 验证配置 模拟 Nginx 访问 切换到 www-data 用户 1 sudo -u www-data bash 尝试访问文件 1 2 cat /home/ubuntu/work/react-todo-demo/dist/index.html exit 检查 Nginx 错误日志 1 sudo tail -f /var/log/nginx/error.log 最佳实践总结 对象 推荐权限 所有权 说明 项目父目录 755 ubuntu:ubuntu 确保 www-data 有 x 权限 构建目录（dist） 755 ubuntu:www-data 组权限方便 Nginx 读取 静态文件（.html） 644 ubuntu:www-data 防止意外修改 可执行文件（.sh） 744 ubuntu:www-data 需要执行权限时使用 ","date":"2025-02-24T19:14:51+08:00","permalink":"https://godvvvzzz.github.io/p/linux-permission/","title":"Linux Permission"},{"content":"Git操作 ssh秘钥 1 2 3 4 5 6 7 8 9 10 11 # 检查是否已有 SSH 密钥 ls -al ~/.ssh # 生成新的 SSH 密钥 ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # 将 SSH 密钥添加到 SSH 代理 eval \u0026#34;$(ssh-agent -s)\u0026#34; # 启动ssh代理 ssh-add ~/.ssh/id_ed25519 # 将私钥添加到 SSH 代理 # 将公钥添加到 GitHub cat ~/.ssh/id_ed25519.pub # 测试 SSH 连接 ssh -T git@github.com config配置 1 2 3 4 5 git config --list # 去掉--global则为当前项目设置 git config --global user.name \u0026#34;weiweiwei\u0026#34; git config --global user.email \u0026#34;2662446324@qq.com\u0026#34; 其他常用命令 1 2 3 4 5 6 7 8 9 #查看远端分支情况 git fetch --all git branch -r #切换远程分支并创建本地分支 git checkout -b feature-branch origin/feature-branch #设置远程和本地分支关联 git branch --set-upstream-to=\u0026lt;远程仓库名\u0026gt;/\u0026lt;远程分支名\u0026gt; \u0026lt;本地分支名\u0026gt; Linux常用命令 查看历史已执行命令 1 2 3 4 5 6 7 8 9 # 查看历史命令 history history | tail -n 10 !123 # 使用 !编号 重新运行某条命令 #可以通过 Ctrl + R 反向搜索历史命令： #按下 Ctrl + R。 #输入关键字（如 git），终端会显示匹配的命令。 #按 Enter 运行该命令，或按 Ctrl + R 继续搜索上一条匹配的命令。 nginx无权限 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 定位权限问题 root@VM-4-3-ubuntu:/home/ubuntu/work/react-todo-front# namei -l /home/ubuntu/work/react-todo-front/dist/index.html f: /home/ubuntu/work/react-todo-front/dist/index.html drwxr-xr-x root root / drwxr-xr-x root root home drwxr-x--x ubuntu ubuntu ubuntu drwxrwxr-x ubuntu ubuntu work drwxr-xr-x root root react-todo-front drwxr-xr-x ubuntu www-data dist -rw-r----- root root index.html # 如上所示，dist目录下的文件 只有root和root组中用户能够读取，nginx无权限读 # 赋予nginx权限 root@VM-4-3-ubuntu:/home/ubuntu/work/react-todo-front# sudo chown -R ubuntu:www-data /home/ubuntu/work/react-todo-front/dist #检查 root@VM-4-3-ubuntu:/home/ubuntu/work/react-todo-front# namei -l /home/ubuntu/work/react-todo-front/dist/index.html f: /home/ubuntu/work/react-todo-front/dist/index.html drwxr-xr-x root root / drwxr-xr-x root root home drwxr-x--x ubuntu ubuntu ubuntu drwxrwxr-x ubuntu ubuntu work drwxr-xr-x root root react-todo-front drwxr-xr-x ubuntu www-data dist -rw-r----- ubuntu www-data index.html vim 文本替换 1 2 # 替换文本 替换整个文件中的所有匹配项 :%s/old/new/g nginx go部署 1 2 3 4 5 ps aux | grep \u0026#34;go-todo-back\u0026#34; | grep -v grep nohup ./go-todo-back \u0026amp;\u0026gt; /home/ubuntu/work/log/go-todo-back/nohup.out \u0026amp; go env -w GOPROXY=https://goproxy.cn,direct MySQL JSON_CONTAINS_PATH(developer_video_v2, \u0026lsquo;one\u0026rsquo;, \u0026lsquo;$.file.cdnurl\u0026rsquo;) = 0\n参数说明 ：\ndeveloper_video_v2 ：要检查的 JSON 字段 'one' ：检查模式，表示只要存在 任意一个指定的路径 就返回 1 （若改为 'all' 则是要求 所有路径必须存在 ，此处因只有一个路径，效果等同） '$.file.cdnurl' ：要探测的 JSON 路径（格式遵循 MySQL JSON 路径语法） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 SELECT * FROM `knight_game` WHERE developer_video_v2 != \u0026#39;\u0026#39; AND IFNULL( JSON_UNQUOTE(developer_video_v2-\u0026gt;\u0026#39;$.file.cdnurl\u0026#39;), \u0026#39;\u0026#39; ) = \u0026#39;\u0026#39;; SELECT * FROM `knight_game` WHERE developer_video_v2 != \u0026#39;\u0026#39; -- 确保字段本身不是空字符串 AND ( -- 检查JSON路径是否不存在 JSON_CONTAINS_PATH(developer_video_v2, \u0026#39;one\u0026#39;, \u0026#39;$.file.cdnurl\u0026#39;) = 0 OR -- 路径存在但值为空字符串（JSON中存储 \u0026#34;\u0026#34;） JSON_UNQUOTE(developer_video_v2-\u0026gt;\u0026#39;$.file.cdnurl\u0026#39;) = \u0026#39;\u0026#39; OR -- 路径存在但值为JSON null（MySQL返回SQL NULL） developer_video_v2-\u0026gt;\u0026#39;$.file.cdnurl\u0026#39; IS NULL ) wsl 直接输入wsl 进入默认ubuntu系统\n","date":"2025-02-24T15:01:17+08:00","permalink":"https://godvvvzzz.github.io/p/notebook-record/","title":"Notebook Record"},{"content":"React 项目部署到腾讯云服务器 本文将介绍如何将 React 项目部署到腾讯云服务器（无需域名），并使用 Nginx 作为 Web 服务器进行配置。\n准备工作 服务器配置 操作系统：推荐 Ubuntu 24.04 LTS 安全组开放端口：80 (HTTP) 和 22 (SSH) 获取服务器公网 IP：如 123.123.123.123 部署步骤 连接服务器 通过 SSH 连接到服务器，使用密码或密钥登录：\n1 ssh root@服务器IP 安装必要环境 首先，更新软件包列表并安装 Node.js 和 Nginx：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 更新软件包列表 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y # 安装 Node.js curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - sudo apt install -y nodejs # 安装 Nginx sudo apt install nginx -y # 验证安装 node -v # 应显示 v20.x nginx -v # 应显示版本号 上传项目文件 将本地 React 项目上传到服务器：\n1 2 3 4 # 本地电脑执行（将本地项目上传到服务器） scp -r ./react-project root@服务器IP:/home/react-project # 或者通过git clone下载仓库 构建生产版本 在服务器端构建 React 应用：\n1 2 3 4 # 服务器端操作 cd /home/react-project npm install npm run build # 生成 build/ 或 dist/ 目录 配置 Nginx 创建 Nginx 配置文件并启用：\n1 2 # 创建 Nginx 配置文件 sudo vim /etc/nginx/sites-available/react-app 在文件中输入以下内容：\n1 2 3 4 5 6 7 8 9 10 server { listen 80; server_name 120.51.70.205; # 无需域名，替换成自己的服务器公网ip root /home/react-project/build; # 根据实际构建目录调整 index index.html; location / { try_files $uri $uri/ /index.html; } } 启用配置：\n1 2 3 sudo ln -s /etc/nginx/sites-available/react-app /etc/nginx/sites-enabled/ sudo nginx -t # 测试配置 sudo systemctl restart nginx 开放防火墙（腾讯云控制台） 登录腾讯云控制台，进入安全组设置，添加入站规则：\n协议：TCP 端口：80 来源：0.0.0.0/0（或你的本地 IP） 本地访问 在浏览器中访问：\n1 http://服务器IP 备选方案：使用 PM2 部署 若需保持开发模式运行（不推荐生产环境）：\n1 2 3 4 5 6 7 8 9 # 全局安装 PM2 npm install pm2 -g # 启动应用 pm2 serve /home/react-project/build 3000 # 设置开机启动 pm2 startup pm2 save 此时访问地址为：\n1 http://服务器IP:3000 后续维护 更新代码 若要更新代码：\n1 2 3 4 5 6 7 # 本地 scp -r ./react-project root@服务器IP:/home/react-project # 服务器 cd /home/react-project npm run build sudo systemctl restart nginx 常用命令 命令 作用 sudo systemctl status nginx 查看 Nginx 状态 journalctl -u nginx -f 查看 Nginx 日志 pm2 list 查看 PM2 进程 注意事项 权限问题：确保 /home/react-project 目录有读取权限。 路径问题：检查 Nginx 配置中的路径与实际构建目录是否一致。 端口冲突：若使用其他端口需同步修改安全组规则。 通过以上步骤即可通过服务器 IP 直接访问部署的 React 应用。后续获取域名后，只需在 Nginx 配置中修改 server_name 并配置 SSL 证书即可升级为 HTTPS 站点。\n","date":"2025-02-23T00:54:07+08:00","permalink":"https://godvvvzzz.github.io/p/react-deploy/","title":"React Deploy"}]