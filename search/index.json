[{"content":"React 渐进式学习路线 📌 学习原则 每个阶段 1-2 个核心项目（保持兴趣和成就感） 遇到问题再补充理论知识（避免过早陷入细节） 先模仿再创造（通过修改现有项目学习） 🚀 阶段路线图 阶段 1：HTML/CSS 生存技能（1-2周） 目标：能修改现有项目的样式和结构\n项目：重构 TodoList 的 UI\n学习重点：\n通过 Chrome 开发者工具调试样式 修改现有 CSS 类名和样式 使用 Flex/Grid 调整布局 添加简单的动画效果 资源：\nFlexbox 小游戏 CSS Diner（CSS 选择器练习） MDN 基础教程 阶段 2：JavaScript 核心操作（2-3周） 目标：能读懂并修改项目中的 JS 逻辑\n项目：给 TodoList 添加新功能\n学习重点：\n添加「编辑任务」功能 实现「本地存储」持久化 添加「任务分类」过滤功能 资源：\nJavaScript 30（每天 1 个小项目） 现代 JavaScript 教程（按需查阅） Codewars（编程挑战） 阶段 3：React 核心模式（3-4周） 目标：理解组件化开发思维\n项目：开发天气查询应用\n学习重点：\n组件拆分技巧（容器组件/展示组件） 掌握 useEffect 处理 API 请求 使用 Context 共享全局状态 资源：\nReact 官方文档（交互式教程） React 模式图解 EpicReact.dev（实战技巧） 阶段 4：现代工具链（2周） 目标：能配置和调试工程化项目\n项目：从零搭建项目脚手架\n学习重点：\n使用 Vite 初始化项目 配置 ESLint + Prettier 添加路由（React Router） 集成状态管理（Zustand/Jotai） 资源：\nVite 官方文档 React Router 教程 阶段 5：实战进阶（4-6周） 目标：体验真实项目开发流程\n项目：开发「个人博客系统」\n功能需求：\n文章列表/详情页 标签分类系统 评论功能 管理员后台 技术栈：\nNext.js（SSR） Markdown 解析 身份验证（NextAuth） 数据库（Supabase） 资源：\nNext.js 官方教程 Supabase 文档 阶段 6：大型项目实战（持续） 目标：培养代码阅读和协作能力\n学习方法：\n参与开源项目（从修改文档开始） 阅读 Ant Design 等优秀组件库源码 学习 Monorepo 项目管理（TurboRepo） 推荐项目：\nReact GitHub 源码 Vercel 开源项目 Shadcn UI（现代组件库） 💡 学习技巧 Debug 优先：遇到报错时先尝试自己解决（学会看错误信息） 暴力修改法：在副本项目里随意修改代码观察效果 3:1 原则：每写 3 小时代码，用 1 小时整理笔记 逆向工程：找到喜欢的网站/应用，尝试用 React 复现 🛠️ 工具推荐 代码沙盒：CodeSandbox（快速实验想法） AI 辅助：Cursor（代码智能补全） 知识管理：Obsidian（构建个人知识库） 📅 每日学习节奏（参考） 时间段 内容 09:00-10:30 项目编码（核心功能开发） 10:30-11:00 休息 + 整理问题清单 11:00-12:00 针对性学习（解决上午问题） 14:00-15:30 代码重构/功能优化 15:30-16:00 社区交流（Stack Overflow） 16:00-17:00 阅读源码/技术文章 通过「需求驱动学习」的方式，在解决实际问题的过程中自然掌握必要知识。记住：大型项目只是多个小功能的组合，保持迭代改进的心态更重要。\n","date":"2025-02-22T00:00:00Z","permalink":"https://godvvvzzz.github.io/p/react-study-plan/","title":"react学习计划"},{"content":"Hugo Stack Starter https://github.com/CaiJimmy/hugo-theme-stack-starter\n这是一个为 Hugo Stack 主题设计的快速上手模板，使用了 Hugo 模块 来加载主题。它提供了基础的主题结构和配置，同时配置了 GitHub Actions，可以自动将网站部署到 GitHub Pages。还包含一个每天自动更新主题的定时任务（cron job）。\n创建 GitHub 仓库 点击 GitHub 上的 Use this template 按钮。 将新仓库命名为 \u0026lt;用户名\u0026gt;.github.io。其中，用户名建议为全小写。 创建 GitHub Codespace 仓库创建完成后，创建一个与之关联的 GitHub Codespace。 Codespace 已经配置好了 Hugo 的最新扩展版本。 在终端中运行命令 hugo server，即可在浏览器中预览你的网站。 配置站点信息 检查仓库中的 config 文件夹，里面是站点的配置文件。 修改 config/_default/config.toml 文件中的 baseurl 属性，填入你的网站 URL。 部署到 GitHub Pages 打开仓库的 Settings -\u0026gt; Pages 页面。 将构建分支从 master 改为 gh-pages。 每次编辑完网站后，只需将更改提交并推送到仓库，GitHub Actions 会自动将网站部署到对应的 GitHub Pages。 如何写博客 本地下载hugo 以ububtu为例\n1. 下载 Hugo 最新版\n访问 Hugo 的 GitHub Releases 页面找到最新版下载链接： Hugo Releases\n或者直接通过命令行下载 hugo_extended 的 Linux 64 位版本：\n1 wget https://github.com/gohugoio/hugo/releases/download/v0.139.3/hugo_extended_0.139.3_Linux-64bit.tar.gz 2. 解压下载的文件\n解压 .tar.gz 文件：\n1 tar -xvzf hugo_extended_0.139.3_Linux-64bit.tar.gz 解压后会生成一个 hugo 二进制文件。\n3. 安装 Hugo\n将解压后的 hugo 二进制文件移动到系统路径（如 /usr/local/bin），以便全局使用：\n1 sudo mv hugo /usr/local/bin/ 4. 验证安装\n运行以下命令验证安装并检查版本：\n1 hugo version 输出示例：\n1 hugo v0.139.3+extended linux/amd64 BuildDate=2024-12-09T10:00:00Z 创建新文章 1 hugo new post/react-study-plan/index.md 在 content/post/react-study-plan/index.mdd 中编辑内容，例如：\n1 2 3 4 5 6 7 8 --- title: \u0026#34;My First Post\u0026#34; date: 2024-12-09 draft: false tags: [\u0026#34;hugo\u0026#34;, \u0026#34;theme\u0026#34;] categories: [\u0026#34;blog\u0026#34;] --- This is my first post with Hugo Stack theme! 启用评论 Stack 主题默认支持 Utterances评论系统，只需要在 /config/params.toml配置以下参数：\n1 2 3 4 5 6 7 8 9 10 ## Comments [comments] enabled = true provider = \u0026#34;utterances\u0026#34; [comments.utterances] repo = \u0026#34;GODVvVZzz/blog-comments\u0026#34; issueTerm = \u0026#34;pathname\u0026#34; # 评论与文章的关联方式，可选 title, pathname, url label = \u0026#34;Comments\u0026#34; # GitHub Issue 的标签名称 theme = \u0026#34;github-light\u0026#34; # 评论框的主题风格 本地预览 在项目根目录下执行hugo server，访问http://localhost:1313/\n标签\u0026amp;tag配置 直接在文章 Front Matter中添加即可\n1 2 3 4 5 6 7 8 9 --- title: \u0026#34;测试文章\u0026#34; date: 2024-12-18 categories: - 测试分类 tags: - 标签1 - 标签2 --- 其他 配置项目git忽略文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # Hugo 缓存目录 .cache/ hugo_stats.json resources/ # 构建输出目录 public/ # Node.js 和前端工具生成的文件（如适用） node_modules/ dist/ # 临时文件和日志 *.log *.lock .DS_Store Thumbs.db *.tmp *.bak # TypeScript 或编辑器相关配置文件 tsconfig.json jsconfig.json # 操作系统或编辑器生成的文件 .idea/ .vscode/ *.swp *~ # Hugo 模块缓存 go.sum go.mod ","date":"2024-12-11T09:44:53+08:00","permalink":"https://godvvvzzz.github.io/p/hugo-stack-study/","title":"记录本博客搭建过程"},{"content":"文件描述符（FD）概述 文件描述符（FD）是操作系统内核用来标识已打开文件的非负整数索引。在程序中，文件描述符用于文件的读写操作，如通过read、write系统调用。在POSIX标准中，文件描述符0、1、2分别代表标准输入、标准输出和标准错误。\nFD泄露现象 当一个进程打开的文件描述符数量超过系统限制（默认为1024），系统将无法为新文件分配描述符，并可能抛出“Too many open files”错误。这通常意味着有未正确关闭的文件或连接，导致描述符占用过高。\n排查步骤 发现问题 ：通过监控系统发现服务的文件描述符数量异常增长。 查找服务PID ：使用ps aux | grep [服务名]命令找出目标服务的进程ID。 查看当前服务占用FD数量 ：执行ls /proc/[PID]/fd | wc -l检查服务当前打开的文件描述符数量。 查看FD使用情况 ：详细列出当前服务的文件描述符使用情况，ls -ls /proc/[PID]/fd。 检查网络连接 ：使用ss -anp |grep [PID]命令查看服务相关的网络连接，帮助定位可能的泄露来源。 典型案例 以某服务的FD泄露为例：\n现象 ：文件描述符持续增长，达到1w+。 原因 ：服务在高QPS（200~300）下调用第三方验证接口，由于HTTP连接默认超时时间较长（60s），且未主动关闭连接，导致大量描述符持续占用。 复现 ：通过脚本模拟高频率请求，持续观察FD数量变化，验证泄露情况。 排查 ：利用上述步骤定位到问题来源为HTTP请求未正确关闭。 代码修改 ：增加了连接超时和读写超时设置，确保连接在指定时间内被关闭，从而释放描述符。 结果 ：服务使用的FD数量显著下降，泄露问题得到解决。 ","date":"2024-12-10T00:00:00Z","permalink":"https://godvvvzzz.github.io/p/fd-leak-investigation/","title":"FD泄露排查"},{"content":"🗺️ 后端工程师成长路径概览 RoadMap:https://cloud.tencent.com.cn/developer/article/2354207\n核心理念：后端工程师的成长是从“实现功能”的编码者，进化为“构建可靠、高效、可扩展系统”的工程师，最终成为能够驾驭技术不确定性、驱动业务发展的决策者。\n深挖底层与业务，系统好奇是根基（好奇） 学抽象建体系，动手实践出真知（学习） 专精设计懂权衡，架构能力是壁垒（架构） 工程协作提效能，影响团队共进步（影响） 严谨韧性保稳定，构建线上确定性（严谨） 名师引路破瓶颈，加速成长为栋梁（加速） 成长维度 初级阶段 (编码者) 进阶阶段 (工程师) 高级阶段 (决策者) 核心关注点 实现功能、完成需求 系统设计、性能优化、稳定性保障 技术战略、业务驱动、团队赋能 技术深度 学习框架、API调用 深挖底层原理（操作系统、网络、数据库） 构建技术体系，形成技术判断力 影响力范围 个人任务、模块代码 团队项目、工程规范、架构设计 跨团队协作、技术规划、人才培养 💡 结论 深度系统好奇心：从“怎么做”到“为什么这么做”\n不满足于表面功能实现，要主动探究底层原理（如操作系统、网络协议、数据库）和业务逻辑的深层原因。这能让你在出现复杂问题时快速定位根因，做出更明智的技术决策。\n高效学习与抽象力\n方法：优先阅读官方文档和源码以获得最准确信息。 关键：勤于动手实践，并通过抽象与归纳，从纷繁的技术和业务中提炼出共通的设计模式和领域模型，构建自己的知识体系。 善用工具：合理利用AI工具辅助代码生成、技术调研和问题排查，但核心是培养自身的技术判断力。 架构与设计能力：从功能实现到系统雕塑\n打造技术专长：在广博的基础上，选择一个如性能优化、分布式系统或安全稳定性等高价值领域进行深度钻研，建立个人技术品牌。 掌握权衡艺术：深刻理解并在性能与成本、一致性与可用性等关键维度之间做出明智的权衡。 输出蓝图：能够产出清晰的技术方案文档和架构图，并清晰地阐述其背后的思考。 工程与协作影响力：从个人贡献者到团队杠杆\n你的价值不再仅仅是你写了多少代码，而在于你如何提升整个团队的效能。这包括：\n对代码：具备“代码洁癖”，积极推动工程规范。 对团队：在评审中提供深度反馈，主动分享知识，赋能他人。 对业务：主动沟通，理解业务背景，用技术手段直接创造业务价值。 严谨与韧性：在不确定性中构建确定性\n这是后端工程师的基石素养。要对线上环境抱有敬畏之心，通过完善的日志、监控和系统性思维来保障稳定性。面对故障和难题，要具备冷静排查和彻底复盘的能力，并拥有“死磕”的韧性。\n关键加速器：寻找“架构师导师”\n一位经验丰富的导师能在你面临技术抉择时点拨迷津，分享宝贵的踩坑经验，并通过高标准的代码评审提供成长反馈。你可以从团队内部或外部技术社区中寻找这样的引路人。\n💎 细节 一、深度系统好奇心：从“怎么做”到“为什么这么做” 对象与行动：\n底层原理：不满足于API调用，深挖操作系统（进程/线程/IO）、网络（TCP/IP/HTTP）、数据库（索引/事务/锁）、中间件（消息队列/缓存）的工作原理。 业务逻辑：深入理解你所支持的业务领域（如电商、社交、金融），明白每一行代码背后的商业意图和用户价值。 依赖生态：了解你使用的框架、组件、云服务的核心机制、优劣和边界。知其然，并知其所以然。 全局架构：跳出自己的一亩三分地，去理解整个系统的架构设计、模块划分、数据流、部署流程以及它们为何如此设计。 目的：在出现疑难杂症时，能快速定位根因；在设计方案时，能做出更符合底层原理和长期发展的明智选择。\n二、高效学习与抽象力：在技术浪潮中屹立不倒 核心方法：\n官方文档优先（深度访谈）：像产品经理访谈用户一样，精读官方文档和源码，这是最一手、最准确的信息。博客和二手教程（电话访谈）可作为辅助，但不能替代。 动手实践（构建原型）：学习新技术时，亲手搭建、写Demo、做压测，在实践中感受其特性和瓶颈。 抽象与归纳：从纷繁复杂的技术和业务逻辑中，抽象出共通的设计模式、架构模式和领域模型。例如，能否将不同的业务需求抽象为统一的任务调度模型？ AI高效辅助： 代码生成与解释：让AI生成样板代码、单元测试、或解释一段复杂的遗留代码。 技术调研：快速获取不同技术方案的对比、最佳实践和潜在风险。 问题排查：提供错误日志，让AI辅助分析可能的原因。 核心：构建自己的知识体系和技术判断力，能快速甄别技术的价值，并将其抽象为可复用的解决方案，而非被动地追逐最新名词。\n三、架构与设计能力：从功能实现到系统雕塑 行动策略：\n打造技术“利基”：在广度之上，选择一个或多个高价值领域深度钻研，建立技术品牌，例如： 性能优化专家：深入JVM/GC、数据库调优、缓存体系、高并发服务。 分布式系统专家：精通微服务治理、分布式事务、一致性协议、弹性设计。 数据领域专家：深耕大数据平台、实时计算、数据仓库与湖仓一体。 安全与稳定性专家：专精于架构安全、流量防护、故障演练、SLA保障。 设计原则与权衡：掌握SOLID、DRY、KISS等设计原则，并能在实际设计中灵活运用。深刻理解并在性能VS成本、一致性VS可用性、开发效率VS系统稳定性、技术前瞻性VS团队技术栈之间做出明智的权衡。 输出蓝图：能够产出清晰的技术方案文档、架构图，并能清晰地阐述技术选型理由、潜在风险和演进路线。 目标：从“实现一个接口”的视角，上升到“设计一个优雅、健壮、易于演进的服务”的层面，成为团队的技术设计核心。\n四、工程与协作影响力：从个人贡献者到团队杠杆 如何升级：\n对代码与工程： 代码洁癖：写出清晰、可读、可维护的代码，视为职业素养。积极重构，偿还技术债。 工程规范推动者：主动推动团队的代码规范、CI/CD流程、单元测试覆盖率、文档文化。 对同事与团队： 高效协作：在设计评审、代码评审中提供建设性、有深度的反馈，帮助团队共同成长。 知识传承：主动分享技术难点、设计思路和复盘总结，将个人能力转化为团队资产。 赋能他人：设计易于理解和使用的接口、SDK、平台工具，降低他人的使用成本。 对业务与产品： 主动沟通：主动与产品/前端沟通，了解业务背景，识别技术风险，提出更优的技术实现方案，而不仅仅是被动接收需求。 用技术创造价值：通过技术手段（如引入缓存、优化查询）直接带来业务指标（如响应时间、吞吐量）的提升，并清晰地展示其价值。 核心：价值不再仅仅是写了多少行代码，而是如何通过技术能力、工程素养和协作精神，提升整个团队的产出效率和质量。\n五、严谨与韧性：在复杂性与不确定性中构建确定性 必备特质：\n严谨性： 敬畏线上：对每一次变更都抱有敬畏之心，严格遵守上线流程，做好回滚预案。 日志与监控：坚信“可观测性是最好的医生”，为自己开发的服务设计完善的日志、监控和告警。 系统性思维： 考虑问题时，能想到上下游依赖、流量洪峰、单点故障、安全漏洞等方方面面。 养成“如果\u0026hellip;会\u0026hellip;”的思维习惯，提前预判风险。 问题驱动与韧性： 面对线上故障，能冷静、清晰、按优先级地进行排查、定位和修复，并事后进行彻底复盘。 面对技术难题，有“死磕”的精神，乐于钻进复杂的代码库和日志中寻找线索。 耐心与远见：懂得“慢就是快”，在前期投入足够的设计和测试时间，避免后期无尽的修补。对技术体系的建设有长期主义的耐心。 六、关键加速器：寻找你的“架构师导师”（Architect Mentor） 为什么至关重要：后端技术的深度和架构设计的艺术，需要高人指点。一位好的导师能帮你：\n点拨迷津：在你面对多个技术方案犹豫不决时，一针见血地指出优劣和背后的权衡。 传授“内功”：分享他踩过的坑、解决问题的思维模式、架构演进的历程，这些是无价之宝。 代码与设计评审：以极高的标准评审你的代码和设计，让你看到差距和提升方向。 提供舞台：给予你负责更具挑战性模块的机会，在实战中锻炼你。 职业导航：帮你规划在技术（专家路线/管理路线）上的成长路径。 如何寻找：\n内部：你的技术主管、架构师团队中的资深成员、你敬佩的其他技术团队负责人。 外部：技术社区/大会上的演讲者、开源项目负责人、技术博客的作者。 关键：带着你思考过的技术方案、遇到的具体难题、或者阅读源码后的困惑去请教，让对方看到你的潜力和诚意。 ","date":"2025-10-27T23:01:41+08:00","permalink":"https://godvvvzzz.github.io/p/backend-dev-plan/","title":"Backend Dev Plan"},{"content":"1️⃣ 深入巩固技术基础 Go语言 (核心中的核心)：\n语法精通： 确保对goroutine, channel, sync包（Mutex, WaitGroup, Cond, Map等）, defer, panic/recover, interface, struct, 反射等核心概念烂熟于心。不仅要会用，要理解其实现原理和适用场景。 并发模型： 深入理解GMP调度模型、channel的底层实现（环形队列）、goroutine泄漏场景与排查、sync包各原语的适用场景和性能差异。这是Go面试的绝对重点。 内存管理： 了解逃逸分析、GC的三色标记法基本原理、GC触发条件、如何减少GC压力（如复用对象、避免小对象频繁分配）。 标准库： 熟练掌握net/http, context, encoding/json (及其他序列化), database/sql, os, time, sync等常用包。 性能优化： 掌握pprof工具的使用（CPU, Memory, Goroutine, Block, Mutex profiling），benchmark测试，理解常见性能瓶颈（锁竞争、GC频繁、低效算法、网络IO）。 依赖管理： 熟悉Go Module的使用和最佳实践。 推荐资源： 《Go语言设计与实现》、《Go语言高级编程》、官方文档、Dave Cheney博客、GopherCon Talks。 计算机基础：\n数据结构与算法： 重点突破： 链表、栈、队列、哈希表、堆（优先队列）、二叉树（遍历、BST）、图（BFS, DFS）、排序（快排、归并、堆排序）、二分查找、双指针、滑动窗口、递归、回溯、动态规划（基础）。 平台刷题： LeetCode是必须的。目标：Easy 100%能做，Medium 高频题和经典题非常熟练（做到bug-free，能分析时空复杂度，能讲清楚思路），Hard题可以尝试理解思路。 刻意练习： 每天坚持，按类型刷，总结模板和易错点。模拟面试环境（白板/在线IDE）。 操作系统： 进程、线程、协程： 区别、通信方式（管道、信号、消息队列、共享内存、Socket）、上下文切换开销。 内存管理： 虚拟内存、分页、分段、页面置换算法。 文件系统： 基本概念（inode, dentry）、IO方式（阻塞/非阻塞/IO多路复用/异步）。 死锁： 条件、预防、避免、检测。 网络： TCP/IP协议栈： 重点掌握TCP（三次握手、四次挥手、状态机、可靠传输机制 - 序列号/确认号/超时重传/滑动窗口/拥塞控制）、UDP、HTTP/HTTPS（报文结构、方法、状态码、Header、Cookie/Session、HTTPS握手流程）。 网络模型： OSI七层模型、TCP/IP五层模型。 网络编程： Socket编程基础（Go的net包就是对socket的封装）。 常用协议： DNS、WebSocket等。 数据库： MySQL (重点)： 索引：B+树原理、聚集/非聚集索引、覆盖索引、最左前缀原则、索引失效场景、索引优化。 事务：ACID、隔离级别（现象 - 脏读、不可重复读、幻读；实现原理 - MVCC, Locking）、锁（行锁、表锁、间隙锁、Next-Key Lock）。 存储引擎：InnoDB vs MyISAM。 优化：Explain分析、慢查询优化、分库分表（概念、场景）。 Redis (重点)： 数据类型及适用场景：String, Hash, List, Set, Sorted Set, Bitmap, HyperLogLog, Geo, Stream。 持久化：RDB, AOF。 高可用：主从复制、哨兵、Cluster模式（分片、槽位）。 淘汰策略。 缓存问题：穿透、击穿、雪崩及其解决方案（布隆过滤器、互斥锁、随机过期时间、多级缓存）。 分布式锁：用Redis实现（SETNX + Lua脚本保证原子性）。 了解其他： 消息队列（Kafka/RabbitMQ/RocketMQ）的基本概念（解耦、削峰、异步）、使用场景、核心术语（Producer, Consumer, Topic, Partition/Queue, Broker）。选一个了解即可。 2️⃣ 深度梳理和包装项目经验 突出业务价值和技术亮点\n聚焦游戏分发业务： 深入挖掘： 不要停留在表面功能描述。思考： 负责的模块/服务解决了什么核心业务问题？（例如：如何保证海量游戏包体快速、稳定地分发到全球CDN节点？如何管理游戏元数据（名称、版本、大小、下载链接）？如何设计高并发的下载调度？如何防止盗链/恶意下载？如何做灰度发布？） 系统面临的挑战是什么？（高并发？低延迟？数据一致性？高可用？） 用了哪些关键技术/架构来解决？（微服务？用了什么框架？数据库选型？缓存策略？消息队列？） 做了哪些关键设计和技术选型？为什么这么选？（对比其他方案优劣） 进行了哪些性能优化？效果如何？（量化指标！例如：QPS从X提升到Y，延迟从A降低到B，节省服务器Z台） 遇到过哪些线上问题/故障？如何排查（用了哪些工具 - pprof, tracing, logs）？如何解决？如何预防？ 代码层面：如何保证代码质量？单元测试？Code Review？设计模式的应用？ STAR法则包装： 为每个项目或重要模块准备清晰的故事线： Situation: 背景是什么？要解决什么问题？ Task: 的具体职责和任务是什么？ Action: 采取了哪些技术行动？（这是重点！要讲清楚技术细节和决策过程） Result: 取得了什么可量化的结果？（性能提升、成本降低、稳定性提高、用户满意度增加等） 突出Go的特性： 在描述项目时，融入Go的最佳实践： 如何利用goroutine和channel实现并发控制/异步处理？ 如何利用context进行超时和取消控制？ 如何设计清晰的interface？ 如何做错误处理？ 如何利用sync包解决并发安全问题？ 准备项目难点和亮点： 每个项目准备1-2个技术难点突破或技术亮点的故事，讲深讲透。 3️⃣ 系统设计能力提升 针对工作年限，要求基础能力\n掌握基础方法论： 明确需求（功能需求、非功能需求 - QPS、延迟、可用性、一致性要求）。 估算（请求量、存储量、带宽 - 费米估算）。 核心组件设计（API设计、数据模型 - 数据库选型及Schema设计、存储设计）。 深入一个方向（根据场景选一个深入，如高可用设计、缓存策略、数据库扩展）。 识别瓶颈并讨论解决方案。 学习经典案例： 必看： 《Grokking the System Design Interview》或类似课程/书籍。 常见题目： 设计短链系统、设计Twitter/微博Feed流、设计秒杀系统、设计聊天系统、设计搜索引擎、设计文件存储服务、设计推荐系统等。理解其通用模式和权衡（CAP）。 结合自身业务思考： 尝试用系统设计的方法论来重新审视你参与过的游戏分发系统： 整个游戏分发平台的架构图是什么样的？ 元数据管理服务如何设计？（DB+Cache） 下载调度服务如何应对高并发？（队列、限流、负载均衡） 如何保证包体分发的速度和正确性？（CDN、校验机制） 如何做监控和报警？ 如果用户量翻10倍，系统哪里会成为瓶颈？如何扩容？ **目标：**能清晰地阐述一个中小型服务的设计思路（比如负责的某个微服务），理解基本组件的用途（为什么用Redis？为什么用MQ？），并能在指导下讨论扩展性、可用性问题。展现设计思维和潜力。 4️⃣ 一些资料收集 后台管理系统 go-admin\n博客 ThriveX-Blog\ngo基础 Go语言设计与实现\nGo语言高级编程\nGo语言圣经\n低代码 ","date":"2025-06-27T15:01:17+08:00","permalink":"https://godvvvzzz.github.io/p/go-study-plan/","title":"Go Study Plan"},{"content":" 核心原则 访问场景 推荐域名类型 说明 前端 → 后端接口 内网域名/IP 前端与后端部署在同一内网，通过反向代理通信，减少公网暴露风险。 客户端 → 后端接口 外网域名 客户端（如移动端、第三方）需通过公网访问，需暴露外网域名并加固安全。 典型场景及配置方案 场景1：纯Web应用（仅前端调用后端） 架构特点：\n前端部署在公网（如Nginx/CDN），后端在内网。 所有接口仅由前端调用，客户端不直接访问后端。 配置方案：\n前端调用后端：Nginx使用内网域名/IP代理后端服务（如 proxy_pass http://internal-api.example.com）。 客户端访问：仅访问前端域名（如 https://www.example.com），不暴露后端接口。 1 2 3 4 5 # 前端Nginx配置 location /api/ { proxy_pass http://internal-api.example.com:8080; # 内网域名 proxy_set_header Host $host; } 场景2：混合应用（前端+客户端均需调用后端） 架构特点：\n后端需同时服务前端（Web）和客户端（App/第三方）。 需区分内部接口和开放接口。 配置方案：\n前端调用后端：通过内网域名/IP（走反向代理）。 客户端调用后端：通过外网域名（如 https://api.example.com），配合API网关、鉴权和限流。 1 2 3 4 5 6 7 8 9 10 # 对外API网关配置 server { listen 443 ssl; server_name api.example.com; # 外网域名 location /public-api/ { proxy_pass http://backend-cluster; # 后端集群内网地址 # 安全加固：API密钥验证、速率限制等 } } 场景3：全开放API服务（如第三方集成） 架构特点： 后端需完全暴露给公网，供多客户端直接调用。 配置方案： 统一使用外网域名（如 https://api.example.com）。 通过API网关管理流量，并启用HTTPS、OAuth2、IP白名单等安全措施。 安全最佳实践 内网通信加固\n使用内网域名/IP，避免后端直接暴露在公网。\n通过防火墙限制后端端口仅允许前端服务器IP访问。\n1 2 3 # 后端服务器防火墙规则（示例） sudo ufw allow from 前端服务器IP to any port 8080 sudo ufw deny 8080 # 禁止其他IP访问 外网接口防护\nHTTPS加密：强制所有外网域名使用SSL/TLS。\n鉴权机制：JWT、OAuth2、API Key等。\n速率限制：防止DDoS和滥用。\n1 2 3 4 5 6 7 # Nginx限流配置 limit_req_zone $binary_remote_addr zone=api_rate:10m rate=10r/s; location /api/ { limit_req zone=api_rate burst=20; proxy_pass http://backend; } 监控与日志\n记录所有外网接口的访问日志。 使用工具（如Prometheus+Grafana）监控API健康状态。 常见误区与解答 误区1：所有接口都需通过外网暴露。 ​解答：仅客户端直接调用的接口需外网域名，前端调用的接口应通过内网通信。 误区2：内网域名不需要HTTPS。 ​解答：内网通信也应启用HTTPS（如自签证书），防止内部流量被窃听。 误区3：外网接口仅靠防火墙保护足够。 ​解答：需多层防御（HTTPS+鉴权+WAF），防火墙仅是第一道屏障。 总结 前端调用后端 → 优先使用内网域名/IP，通过反向代理隐藏后端。 客户端调用后端 → 使用外网域名，严格加固安全策略。 始终遵循最小暴露原则，减少攻击面，结合业务需求设计网络架构。 场景1 详解 在前后端分离的架构中，通过 Nginx 反向代理实现浏览器间接访问内网后端服务的链路如下：\n完整交互流程（以访问 https://example.com 为例）\n1 2 3 4 5 6 7 8 9 10 11 sequenceDiagram participant 浏览器 participant 前端服务器(Nginx) participant 后端服务器 浏览器-\u0026gt;\u0026gt;前端服务器(Nginx): 1. 请求前端页面（GET /） 前端服务器(Nginx)-\u0026gt;\u0026gt;浏览器: 2. 返回HTML/CSS/JS文件 浏览器-\u0026gt;\u0026gt;前端服务器(Nginx): 3. 发起API请求（GET /api/todos） 前端服务器(Nginx)-\u0026gt;\u0026gt;后端服务器: 4. 转发请求到内网地址（如http://10.0.0.2:8080） 后端服务器-\u0026gt;\u0026gt;前端服务器(Nginx): 5. 返回API响应数据 前端服务器(Nginx)-\u0026gt;\u0026gt;浏览器: 6. 返回数据给浏览器 关键步骤详解 浏览器请求前端页面 用户输入：访问 https://example.com。 DNS解析：浏览器通过DNS查询得到 example.com 的公网IP（如 122.51.70.205）。 请求前端资源：浏览器向该IP的80/443端口发送请求，获取 index.html 和静态资源（JS/CSS）。 前端服务器（Nginx）响应静态文件 Nginx配置：托管前端打包后的文件。\n1 2 3 4 5 6 7 8 9 10 server { listen 80; server_name example.com; root /var/www/dist; # 前端文件目录 index index.html; location / { try_files $uri $uri/ /index.html; # 处理前端路由 } } 浏览器执行JS代码发起API请求 前端代码逻辑：JS中调用 fetch(\u0026quot;/api/todos\u0026quot;)。 实际请求地址：浏览器会将其解析为 https://example.com/api/todos（同源请求）。 Nginx代理转发到后端服务器 Nginx反向代理规则：匹配/api/路径，转发到内网后端。\n1 2 3 4 5 location /api/ { proxy_pass http://10.0.0.2:8080; # 后端内网IP和端口 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } 内网通信：Nginx将请求发送到后端服务器的内网地址 10.0.0.2:8080。\n后端服务器处理请求 监听端口：后端服务运行在内网服务器的 8080 端口。 安全限制：防火墙仅允许来自前端服务器IP的请求（如 10.0.0.1）。 数据返回浏览器 响应路径：后端 → Nginx → 浏览器。 浏览器视角：全程只与 example.com 通信，感知不到后端服务器的存在。 为什么后端无需暴露公网？ Nginx的中转作用\n所有请求通过Nginx进入，后端服务只需在内网监听端口，无需公网IP或端口映射。 防火墙保护\n后端服务器的防火墙可配置为仅接受来自前端服务器内网IP的请求：\n1 2 3 # 后端服务器防火墙规则（示例） sudo ufw allow from 10.0.0.1 to any port 8080 # 仅允许前端服务器访问 sudo ufw deny 8080 # 禁止其他IP访问 安全性提升\n后端不暴露公网，减少被扫描攻击的风险。 常见问题解答 Q1：为什么浏览器不直接请求后端地址？ 同源策略：前端代码部署在 example.com，若直接请求 http://10.0.0.2:8080/api 会触发跨域错误（CORS）。 解决方案：通过Nginx代理统一域名，规避跨域问题。 Q2：如何保证内网通信安全？ 使用VPN或专线：前后端服务器通过私有网络通信。 内网HTTPS：即使在内网，也建议为后端服务启用HTTPS。 Q3：如何扩展多台后端服务器？ 负载均衡：在Nginx中配置upstream模块：\n1 2 3 4 5 6 7 upstream backend { server 10.0.0.2:8080 weight=1; server 10.0.0.3:8080 weight=2; } location /api/ { proxy_pass http://backend; } 总结 核心逻辑：Nginx作为中间层，将公网请求转发到内网后端，隐藏后端细节。 安全要点：后端仅在内网监听，通过防火墙限制访问来源。 优势：前端域名统一管理请求，提升安全性和扩展性。 dns nginx如何协作的 1. DNS 解析阶段：域名到 Nginx 服务器的 IP 用户访问域名：例如 https://www.example.com。 DNS 查询： 浏览器向本地 DNS 缓存或运营商 DNS 服务器查询 www.example.com 的 IP。 DNS 服务器返回该域名对应的 Nginx 服务器的公网 IP（如 122.51.70.205）。 结果：浏览器的所有请求（无论路径是 /、/api/xxx 或其他）都会发送到 122.51.70.205 的 80/443 端口。 2. Nginx 接收请求后的处理逻辑 Nginx 不依赖域名后缀（如 /api），而是通过以下两个关键机制确定如何转发请求：\n5(1) 根据 Host 头匹配 server 块\nHTTP 请求头：浏览器在请求中自动携带 Host: www.example.com。\nNginx 配置：通过server_name匹配域名，决定由哪个server块处理请求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 示例：处理 www.example.com 的请求 server { listen 80; server_name www.example.com; # 关键！匹配 Host 头 location / { root /var/www/html; # 返回前端页面 } location /api/ { proxy_pass http://backend; # 转发到后端 } } # 另一个域名（如 api.example.com）的配置 server { listen 80; server_name api.example.com; # 匹配不同 Host 头 location / { proxy_pass http://another-backend; # 转发到其他后端 } } 核心逻辑： Nginx 通过 server_name 区分不同域名的请求，即使它们指向同一个 IP。\n(2) 根据 location 块匹配路径\n路径匹配：在同一个server块内，通过location规则（如/api/）进一步决定是否转发到后端。\n1 2 3 location /api/ { proxy_pass http://10.0.0.2:8080; # 转发到内网后端 } 最终流程： 域名解析 → Nginx 接收请求 → 匹配 server_name → 匹配 location → 转发或返回静态文件。\n3. 为什么域名后缀（如 /api）不是关键？ 误区澄清： Nginx ​不依赖 URL 中的域名后缀​（如 https://www.example.com/api/xxx 中的 api 路径）来决定转发，而是通过以下两步： 域名级别：根据 Host 头选择 server 块（如 www.example.com vs api.example.com）。 路径级别：在选中的 server 块内，根据 location 匹配路径（如 /api/）。 示例场景： 如果用户访问https://www.example.com/api/todos： Nginx 先匹配 server_name www.example.com 的 server 块。 再通过 location /api/ 将请求转发到后端。 如果用户访问https://api.example.com/todos： Nginx 匹配 server_name api.example.com 的 server 块。 根据该 server 块的 location / 直接转发到另一个后端。 关键总结 DNS 解析只是入口： 仅负责将域名解析到 Nginx 服务器的 IP，不涉及后续路径处理。 Nginx 的核心匹配逻辑： 第 1 层：通过 server_name 匹配域名（Host 头）。 第 2 层：通过 location 匹配路径。 隐藏后端的关键： 浏览器始终只与 Nginx 通信，后端服务的 IP、端口、内网架构对浏览器完全透明。 配置示例：多域名 + 路径转发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 域名 www.example.com：处理前端页面和API server { listen 80; server_name www.example.com; # 前端静态资源 location / { root /var/www/html; index index.html; } # 转发API请求到后端 location /api/ { proxy_pass http://10.0.0.2:8080; } } # 域名 api.example.com：直接转发到另一个后端 server { listen 80; server_name api.example.com; location / { proxy_pass http://10.0.0.3:8080; } } 测试方法 验证 DNS 解析：\n1 dig www.example.com # 查看是否返回 Nginx 服务器 IP 验证 Nginx 域名匹配：\n1 2 3 # 模拟携带不同 Host 头的请求 curl -H \u0026#34;Host: www.example.com\u0026#34; http://122.51.70.205/api/todos curl -H \u0026#34;Host: api.example.com\u0026#34; http://122.51.70.205/todos 浏览器调试：\n在浏览器开发者工具的 Network 选项卡中，观察请求的 Host 头和响应来源。 常见问题 Q1：如果多个域名指向同一个 IP，Nginx 如何区分？\n答案：通过 server_name 匹配请求头中的 Host 字段，无需不同 IP。 Q2：Nginx 能根据 URL 路径（如 /api）直接转发吗？\n答案：可以，但需在同一 server 块内配置 location 规则，而不是依赖域名后缀。 Q3：如何实现类似 https://example.com/api 和 https://api.example.com 的共存？\n方案： https://example.com/api → 使用 server_name example.com + location /api。 https://api.example.com → 使用 server_name api.example.com + location /。 通过以上机制，Nginx 完美实现了 域名解析 → 请求分发 → 后端隐藏 的全链路控制。\n","date":"2025-02-27T00:49:52+08:00","permalink":"https://godvvvzzz.github.io/p/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%9F%E5%90%8D%E4%BD%BF%E7%94%A8%E6%8E%A2%E8%AE%A8/","title":"前后端域名使用探讨"},{"content":"Linux 文件权限基础 权限三元组 Linux 中每个文件/目录的权限由 3 组字符表示（共 9 位）：\n1 2 3 4 rwx rwx rwx │││ │││ │││ └┬┘ └┬┘ └┬┘ Owner Group Others r = 读 (4)\nw = 写 (2)\nx = 执行/进入目录 (1)\n数字表示法 755 = rwxr-xr-x\n644 = rw-r--r--\n777 = rwxrwxrwx（危险！）\nNginx 权限需求分析 Nginx 运行身份 默认以 www-data 用户和组运行（可通过 ps aux | grep nginx 确认）。 需要至少以下权限： 目录：r-x（读 + 执行）\n文件：r--（读）\n关键路径 假设你的项目路径为： 1 /home/ubuntu/work/react-todo-demo/dist/ 分步权限配置指南 步骤 1：检查当前权限 查看完整路径权限链（关键！） 1 namei -l /home/ubuntu/work/react-todo-demo/dist/index.html 示例输出：\n1 2 3 4 5 6 7 8 f: /home/ubuntu/work/react-todo-demo/dist/index.html drwxr-xr-x root root / drwxr-xr-x root root home drwxr-x--- ubuntu ubuntu ubuntu # 问题所在！ drwxrwxr-x ubuntu ubuntu work drwxrwxr-x ubuntu ubuntu react-todo-demo drwxrwxrwx www-data www-data dist -rwxrwxrwx www-data www-data index.html 步骤 2：设置父目录权限 开放父目录的 x 权限（允许进入目录） 1 2 3 sudo chmod o+x /home/ubuntu sudo chmod o+x /home/ubuntu/work sudo chmod o+x /home/ubuntu/work/react-todo-demo 验证 1 namei -l /home/ubuntu/work/react-todo-demo/dist/index.html | grep ubuntu 应看到类似：\n1 drwx--x--x 步骤 3：设置项目目录权限 进入项目目录 1 cd /home/ubuntu/work/react-todo-demo 设置目录权限（755 = owner 可写，其他人只读+执行） 1 sudo find dist/ -type d -exec chmod 755 {} \\; 设置文件权限（644 = owner 可写，其他人只读） 1 sudo find dist/ -type f -exec chmod 644 {} \\; 验证 1 ls -l dist/ 应显示：\n1 2 drwxr-xr-x 目录 -rw-r--r-- 文件 步骤 4：设置所有权（推荐方案） 将目录组改为 www-data 1 sudo chown -R ubuntu:www-data /home/ubuntu/work/react-todo-demo/dist 设置组写权限（可选，如果你需要自动构建） 1 sudo chmod -R g+w dist/ 最终权限结构：\ndrwxrwxr-x 目录（owner:ubuntu, group:www-data）\n-rw-rw-r-- 文件（owner:ubuntu, group:www-data）\n安全增强配置 方案 A：严格模式（推荐） 父目录权限（仅允许 ubuntu 用户和组访问） 1 2 3 sudo chmod 750 /home/ubuntu sudo chmod 750 /home/ubuntu/work sudo chmod 750 /home/ubuntu/work/react-todo-demo 将 www-data 用户加入 ubuntu 组 1 sudo usermod -aG ubuntu www-data 项目目录权限 1 2 sudo chmod -R 750 /home/ubuntu/work/react-todo-demo/dist sudo chown -R ubuntu:ubuntu /home/ubuntu/work/react-todo-demo/dist 方案 B：宽松模式（快速修复） 宽松权限配置 1 2 sudo chmod -R 755 /home/ubuntu/work/react-todo-demo sudo chown -R ubuntu:www-data /home/ubuntu/work/react-todo-demo SELinux/AppArmor 处理 如果系统启用了强制访问控制：\n临时禁用（测试用） 1 2 sudo setenforce 0 # SELinux sudo systemctl stop apparmor # AppArmor 永久解决方案 1 2 sudo semanage fcontext -a -t httpd_sys_content_t \u0026#34;/home/ubuntu/work/react-todo-demo/dist(/.*)?\u0026#34; sudo restorecon -Rv /home/ubuntu/work/react-todo-demo/dist 验证配置 模拟 Nginx 访问 切换到 www-data 用户 1 sudo -u www-data bash 尝试访问文件 1 2 cat /home/ubuntu/work/react-todo-demo/dist/index.html exit 检查 Nginx 错误日志 1 sudo tail -f /var/log/nginx/error.log 最佳实践总结 对象 推荐权限 所有权 说明 项目父目录 755 ubuntu:ubuntu 确保 www-data 有 x 权限 构建目录（dist） 755 ubuntu:www-data 组权限方便 Nginx 读取 静态文件（.html） 644 ubuntu:www-data 防止意外修改 可执行文件（.sh） 744 ubuntu:www-data 需要执行权限时使用 ","date":"2025-02-24T19:14:51+08:00","permalink":"https://godvvvzzz.github.io/p/linux-permission/","title":"Linux Permission"},{"content":"Git操作 ssh秘钥 1 2 3 4 5 6 7 8 9 10 11 # 检查是否已有 SSH 密钥 ls -al ~/.ssh # 生成新的 SSH 密钥 ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # 将 SSH 密钥添加到 SSH 代理 eval \u0026#34;$(ssh-agent -s)\u0026#34; # 启动ssh代理 ssh-add ~/.ssh/id_ed25519 # 将私钥添加到 SSH 代理 # 将公钥添加到 GitHub cat ~/.ssh/id_ed25519.pub # 测试 SSH 连接 ssh -T git@github.com config配置 1 2 3 4 5 git config --list # 去掉--global则为当前项目设置 git config --global user.name \u0026#34;weiweiwei\u0026#34; git config --global user.email \u0026#34;2662446324@qq.com\u0026#34; 其他常用命令 1 2 3 4 5 6 7 8 9 #查看远端分支情况 git fetch --all git branch -r #切换远程分支并创建本地分支 git checkout -b feature-branch origin/feature-branch #设置远程和本地分支关联 git branch --set-upstream-to=\u0026lt;远程仓库名\u0026gt;/\u0026lt;远程分支名\u0026gt; \u0026lt;本地分支名\u0026gt; Linux常用命令 查看历史已执行命令 1 2 3 4 5 6 7 8 9 # 查看历史命令 history history | tail -n 10 !123 # 使用 !编号 重新运行某条命令 #可以通过 Ctrl + R 反向搜索历史命令： #按下 Ctrl + R。 #输入关键字（如 git），终端会显示匹配的命令。 #按 Enter 运行该命令，或按 Ctrl + R 继续搜索上一条匹配的命令。 nginx无权限 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 定位权限问题 root@VM-4-3-ubuntu:/home/ubuntu/work/react-todo-front# namei -l /home/ubuntu/work/react-todo-front/dist/index.html f: /home/ubuntu/work/react-todo-front/dist/index.html drwxr-xr-x root root / drwxr-xr-x root root home drwxr-x--x ubuntu ubuntu ubuntu drwxrwxr-x ubuntu ubuntu work drwxr-xr-x root root react-todo-front drwxr-xr-x ubuntu www-data dist -rw-r----- root root index.html # 如上所示，dist目录下的文件 只有root和root组中用户能够读取，nginx无权限读 # 赋予nginx权限 root@VM-4-3-ubuntu:/home/ubuntu/work/react-todo-front# sudo chown -R ubuntu:www-data /home/ubuntu/work/react-todo-front/dist #检查 root@VM-4-3-ubuntu:/home/ubuntu/work/react-todo-front# namei -l /home/ubuntu/work/react-todo-front/dist/index.html f: /home/ubuntu/work/react-todo-front/dist/index.html drwxr-xr-x root root / drwxr-xr-x root root home drwxr-x--x ubuntu ubuntu ubuntu drwxrwxr-x ubuntu ubuntu work drwxr-xr-x root root react-todo-front drwxr-xr-x ubuntu www-data dist -rw-r----- ubuntu www-data index.html vim 文本替换 1 2 # 替换文本 替换整个文件中的所有匹配项 :%s/old/new/g nginx go部署 1 2 3 4 5 ps aux | grep \u0026#34;go-todo-back\u0026#34; | grep -v grep nohup ./go-todo-back \u0026amp;\u0026gt; /home/ubuntu/work/log/go-todo-back/nohup.out \u0026amp; go env -w GOPROXY=https://goproxy.cn,direct MySQL JSON_CONTAINS_PATH(developer_video_v2, \u0026lsquo;one\u0026rsquo;, \u0026lsquo;$.file.cdnurl\u0026rsquo;) = 0\n参数说明 ：\ndeveloper_video_v2 ：要检查的 JSON 字段 'one' ：检查模式，表示只要存在 任意一个指定的路径 就返回 1 （若改为 'all' 则是要求 所有路径必须存在 ，此处因只有一个路径，效果等同） '$.file.cdnurl' ：要探测的 JSON 路径（格式遵循 MySQL JSON 路径语法） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 SELECT * FROM `knight_game` WHERE developer_video_v2 != \u0026#39;\u0026#39; AND IFNULL( JSON_UNQUOTE(developer_video_v2-\u0026gt;\u0026#39;$.file.cdnurl\u0026#39;), \u0026#39;\u0026#39; ) = \u0026#39;\u0026#39;; SELECT * FROM `knight_game` WHERE developer_video_v2 != \u0026#39;\u0026#39; -- 确保字段本身不是空字符串 AND ( -- 检查JSON路径是否不存在 JSON_CONTAINS_PATH(developer_video_v2, \u0026#39;one\u0026#39;, \u0026#39;$.file.cdnurl\u0026#39;) = 0 OR -- 路径存在但值为空字符串（JSON中存储 \u0026#34;\u0026#34;） JSON_UNQUOTE(developer_video_v2-\u0026gt;\u0026#39;$.file.cdnurl\u0026#39;) = \u0026#39;\u0026#39; OR -- 路径存在但值为JSON null（MySQL返回SQL NULL） developer_video_v2-\u0026gt;\u0026#39;$.file.cdnurl\u0026#39; IS NULL ) wsl 直接输入wsl 进入默认ubuntu系统\n","date":"2025-02-24T15:01:17+08:00","permalink":"https://godvvvzzz.github.io/p/notebook-record/","title":"Notebook Record"},{"content":"React 项目部署到腾讯云服务器 本文将介绍如何将 React 项目部署到腾讯云服务器（无需域名），并使用 Nginx 作为 Web 服务器进行配置。\n准备工作 服务器配置 操作系统：推荐 Ubuntu 24.04 LTS 安全组开放端口：80 (HTTP) 和 22 (SSH) 获取服务器公网 IP：如 123.123.123.123 部署步骤 连接服务器 通过 SSH 连接到服务器，使用密码或密钥登录：\n1 ssh root@服务器IP 安装必要环境 首先，更新软件包列表并安装 Node.js 和 Nginx：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 更新软件包列表 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y # 安装 Node.js curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - sudo apt install -y nodejs # 安装 Nginx sudo apt install nginx -y # 验证安装 node -v # 应显示 v20.x nginx -v # 应显示版本号 上传项目文件 将本地 React 项目上传到服务器：\n1 2 3 4 # 本地电脑执行（将本地项目上传到服务器） scp -r ./react-project root@服务器IP:/home/react-project # 或者通过git clone下载仓库 构建生产版本 在服务器端构建 React 应用：\n1 2 3 4 # 服务器端操作 cd /home/react-project npm install npm run build # 生成 build/ 或 dist/ 目录 配置 Nginx 创建 Nginx 配置文件并启用：\n1 2 # 创建 Nginx 配置文件 sudo vim /etc/nginx/sites-available/react-app 在文件中输入以下内容：\n1 2 3 4 5 6 7 8 9 10 server { listen 80; server_name 120.51.70.205; # 无需域名，替换成自己的服务器公网ip root /home/react-project/build; # 根据实际构建目录调整 index index.html; location / { try_files $uri $uri/ /index.html; } } 启用配置：\n1 2 3 sudo ln -s /etc/nginx/sites-available/react-app /etc/nginx/sites-enabled/ sudo nginx -t # 测试配置 sudo systemctl restart nginx 开放防火墙（腾讯云控制台） 登录腾讯云控制台，进入安全组设置，添加入站规则：\n协议：TCP 端口：80 来源：0.0.0.0/0（或你的本地 IP） 本地访问 在浏览器中访问：\n1 http://服务器IP 备选方案：使用 PM2 部署 若需保持开发模式运行（不推荐生产环境）：\n1 2 3 4 5 6 7 8 9 # 全局安装 PM2 npm install pm2 -g # 启动应用 pm2 serve /home/react-project/build 3000 # 设置开机启动 pm2 startup pm2 save 此时访问地址为：\n1 http://服务器IP:3000 后续维护 更新代码 若要更新代码：\n1 2 3 4 5 6 7 # 本地 scp -r ./react-project root@服务器IP:/home/react-project # 服务器 cd /home/react-project npm run build sudo systemctl restart nginx 常用命令 命令 作用 sudo systemctl status nginx 查看 Nginx 状态 journalctl -u nginx -f 查看 Nginx 日志 pm2 list 查看 PM2 进程 注意事项 权限问题：确保 /home/react-project 目录有读取权限。 路径问题：检查 Nginx 配置中的路径与实际构建目录是否一致。 端口冲突：若使用其他端口需同步修改安全组规则。 通过以上步骤即可通过服务器 IP 直接访问部署的 React 应用。后续获取域名后，只需在 Nginx 配置中修改 server_name 并配置 SSL 证书即可升级为 HTTPS 站点。\n","date":"2025-02-23T00:54:07+08:00","permalink":"https://godvvvzzz.github.io/p/react-deploy/","title":"React Deploy"}]